<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* No more scrolling for you! */
            background-color: #f0f0f0; /* Set a background color */
            user-select: none;
            -webkit-user-select: none; /* For Safari */
            -moz-user-select: none; /* For Firefox */
             -ms-user-select: none; /* For Internet Explorer/Edge */
        }

        :root {
            --grid-size: 20px; /* Define the grid size variable */
        }

        #scoreDisplay {
            margin-top: calc(var(--grid-size) * 1.5); /* Adjust margin based on grid size */
            position: fixed;
            font-size: var(--grid-size); /* Set font size equal to grid size */
            user-select: none;
            z-index: 9999;  
            -webkit-user-select: none; /* For Safari */
            -moz-user-select: none; /* For Firefox */
             -ms-user-select: none; /* For Internet Explorer/Edge */
        }

      canvas {
            position: fixed;
            top: 0px; /* Adjust the top position as needed */
            bottom: 0px; /* Adjust the bottom position as needed */
            border: 1px solid #ddd;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* Add a subtle shadow to the canvas */
        }
        body {
            overflow: hidden; /* Disable scrolling */
            touch-action: none; /* Disable touch actions on the canvas */
            user-select: none;
            -webkit-user-select: none; /* For Safari */
            -moz-user-select: none; /* For Firefox */
             -ms-user-select: none; /* For Internet Explorer/Edge */
}
    </style>
    <title>Snake Game</title>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/tinycolor2@1.4.2/dist/tinycolor-min.js"></script>
    <div id="scoreDisplay">Score: 0</div>
    <canvas id="snakeCanvas"></canvas>
        <div id="victoryMessage"></div>
    <script>
        const canvas = document.getElementById('snakeCanvas');
        const ctx = canvas.getContext('2d');

let isSlow = false
        let gravitycount = 1
        let snakecutgravity = false
        let lavacoords = []
        let goombadirection = 'left'
        let goombaoffset = 1.00
        let reflector = []
        let isFast = false
        let timezone = []
        let mirrors = []
        let gotextralife = false;
        let lives = 0.5;
        let gamefoods = [];
        let maxscore = 100;
        let isPossessed = false
        let psize = 20;
        let item = []
        let startingGridSize = 20;
        let gridSize = 20;
        let flaming = false
        let startingLength = 5;
        let snake = Array.from({ length: startingLength }, (_, index) => ({ x: 10, y: 10 - index, color: 'green' }));
        let snake2 = Array.from({ length: startingLength }, (_, index) => ({ x: 10, y: 10 - index, color: 'green' }));
        let food = { x: 0, y: 0};
        let obstacles = []
        let kamekappears = false
        let firstControlSchemeSet = false;
        let dynamicObstacles = [];
        let direction = 'right';
        let previousDirection = 'direction';
        let score = 0;
        let hascollided = false
        let isEating = false;
        let eatingAnimationFrames = 0;
        let isInvincible = false;
        let invincibilityDuration = 0;
        let isColliding = false;
        let kamek = []
        let DoDisplayCheck = true
        let collisionAnimationFrames = 10;
        let isPaused = false;
        let charging = false;
        let freeze = false;
        let freezetimer = 5;
        let isFoodOrange = false;
        let inverted = false;
        let livecount = 2;
        let pausetimer = 900;
        let TaxFormGot = false
        let isParalyzed = false
        let choseobject = false
        let snakeprojectilecollisiontime = 2000
        let originalSnakeColor = '#00FF00';
        let neoncolor = '#39ff14';
        let sunset = '#00FFFF'
        let welldeleter = '#00FFFF80'
        let taxrate = 0.20
        let timeslow = '#00ff8c'
        let timespeed = '#ff0073'
        let LaserCooldownReset = 35
        let esnake = [];
        let turrets = []
        let symbiote = [];
        let controlsinverted = false
        let hasBeenTaxed = false
        let laserTimer = 35
        let controltype = 'set'
        let goombas = []
        let chaosdefeated = false
        let magic = []
        let isIced= false
        var deviceWidth, landscape = Math.abs(window.orientation) == 90
            // workaround for strange screen.height on the iPhone (v3.1.3)
            if (window.screen.width == 320) deviceWidth = landscape ? 480 : 320
            else deviceWidth = window.screen[landscape ? "height" : "width"]
            var zoomFactor = deviceWidth / window.innerWidth;
            var antiZoomFactor = 1 / zoomFactor;
       let currentInterval = 1;
        let track = []
let thwomps = []
let pX = 0;
let wellStrength = 4
let firelord = []
     let lightninglord = []
        let icelord = []
        let earthlord = []
        let ghostLord = []
         let chaosLord = [];
let pY = 0;
let numberOfProjectiles = 10; // Number of projectiles in the wave
const waveSpreadAngle = 180; // Spread angle of the wave (in degrees)
const projectileSpeed = 10; // Speed of the projectiles
const projectileColor = 'orange'; // Color of the projectiles
let projectiles = []; // Array to store projectiles
let enemymovementspeed = 1
    let wellcolor = '#00000080'
let wells = []
let polygons = []
let isGravityWellActive = true;
let effectApplied = 0
let isConfused = false
let isBurned = false
let isTaxed = false
let paratime = 5
let GravityApplied = true
let magicstatus = 0
let lightbrown = '#C4A484'
let kamekcanteleport = true
let sideshield = 6
        let shield = false
let magictype = 'bolt'
        let lightningboltcolor = '#d5ff03'
        let lava = []
        let lavacolor = '#ffa50080'
        let electric = []
        let ice =[]
        let isStunnedFrFall = false
        let fallingVelociy = 0
        let icecolor = '#77A0F280'
        let electriccolor = '#CFFF0480'
        let earthcolor = '#BD978E'
        let earth = []
        let wellWarning = []
        let isghostdead = false
        let ectoplasm = []
        let isEarthed = false
        let scoreAreaArray = []
        let scorecolornoalpha = '#FF0000'
        let alphacolor = '4D'
        const scorecolorarray = [scorecolornoalpha, alphacolor];
const fruitString = scorecolorarray.join("");
let scorecolor = fruitString
let physicsActive = false;  // Flag to activate physics on collision
let ghostcolor = '#1F635780'


function checkAndToggleGravity() {
    if (kamek.length === 0 && firelord.length === 0 && icelord.length === 0 && lightninglord.length === 0 && earthlord.length === 0 && !isPaused && ghostLord.length === 0) { 
        GravityApplied = !GravityApplied;
        gravitycount += 1
    } else {
        GravityApplied = false;
        }
    }

        
setInterval(checkAndToggleGravity, 30000);

        
function addLavaArea(x, y, size, countdown) {
    let offset = Math.floor(size / 2);

    // Assuming canvasWidth and canvasHeight are the dimensions of your canvas
    let canvasWidth = Math.floor(canvas.width / gridSize); // Example canvas width
    let canvasHeight = Math.floor(canvas.height / gridSize); // Example canvas height
    
    for (let i = -offset; i <= offset; i++) {
        for (let j = -offset; j <= offset; j++) {
            lava.push({ x: Math.floor(x + i), y: Math.floor(y + j), countdown:countdown});
        }
    }
    
}
        
function lightningArea(x, y, size, countdown) {
    let offset = Math.floor(size / 2);

    // Assuming canvasWidth and canvasHeight are the dimensions of your canvas
    let canvasWidth = Math.floor(canvas.width / gridSize); // Example canvas width
    let canvasHeight = Math.floor(canvas.height / gridSize); // Example canvas height
    
    for (let i = -offset; i <= offset; i++) {
        for (let j = -offset; j <= offset; j++) {
            electric.push({ x: Math.floor(x + i), y: Math.floor(y + j), countdown:countdown});
        }
    }
    
}

function earthArea(x, y, size, countdown) {
    let offset = Math.floor(size / 2);

    // Assuming canvasWidth and canvasHeight are the dimensions of your canvas
    let canvasWidth = Math.floor(canvas.width / gridSize); // Example canvas width
    let canvasHeight = Math.floor(canvas.height / gridSize); // Example canvas height
    
    for (let i = -offset; i <= offset; i++) {
        for (let j = -offset; j <= offset; j++) {
            earth.push({ x: Math.floor(x + i), y: Math.floor(y + j), countdown:countdown});
        }
    }
    
}

        function ghostArea(x, y, size, countdown) {
    let offset = Math.floor(size / 2);

    // Assuming canvasWidth and canvasHeight are the dimensions of your canvas
    let canvasWidth = Math.floor(canvas.width / gridSize); // Example canvas width
    let canvasHeight = Math.floor(canvas.height / gridSize); // Example canvas height
    
    for (let i = -offset; i <= offset; i++) {
        for (let j = -offset; j <= offset; j++) {
            ectoplasm.push({ x: Math.floor(x + i), y: Math.floor(y + j), countdown:countdown});
        }
    }
    
}

    
function iceArea(x, y, size, countdown) {
    let offset = Math.floor(size / 2);

    // Assuming canvasWidth and canvasHeight are the dimensions of your canvas
    let canvasWidth = Math.floor(canvas.width / gridSize); // Example canvas width
    let canvasHeight = Math.floor(canvas.height / gridSize); // Example canvas height
    
    for (let i = -offset; i <= offset; i++) {
        for (let j = -offset; j <= offset; j++) {
            ice.push({ x: Math.floor(x + i), y: Math.floor(y + j), countdown:countdown});
        }
    }
    
}
        
function scoreArea(x, y, size) {
    let offset = Math.floor(size / 2);

    // Assuming canvasWidth and canvasHeight are the dimensions of your canvas
    let canvasWidth = Math.floor(canvas.width / gridSize); // Example canvas width
    let canvasHeight = Math.floor(canvas.height / gridSize); // Example canvas height
    
    for (let i = -offset; i <= offset; i++) {
        for (let j = -offset; j <= offset; j++) {
            scoreAreaArray.push({ x: Math.floor(x + i), y: Math.floor(y + j)});
        }
    }
    
}

function wellWarningArea(x, y, size) {
    let offset = Math.floor(size / 2);

    // Assuming canvasWidth and canvasHeight are the dimensions of your canvas
    let canvasWidth = Math.floor(canvas.width / gridSize); // Example canvas width
    let canvasHeight = Math.floor(canvas.height / gridSize); // Example canvas height
    
    for (let i = -offset; i <= offset; i++) {
        for (let j = -offset; j <= offset; j++) {
            wellWarning.push({ x: Math.floor(x + i), y: Math.floor(y + j)});
        }
    }
    
}

function removeDuplicatesWithSameCoordinates(arr) {
    // Iterate through the array
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            // Check if both items have the same coordinates
            if (arr[i].x === arr[j].x && arr[i].y === arr[j].y) {
                // Remove one of the items (splice the array)
                arr.splice(j, 1);
                // Since we removed an element, adjust j to stay in sync with the array length
                j--;
            }
        }
    }
    return arr;
}

function removeDuplicateWellWarnings() {
removeDuplicatesWithSameCoordinates(wellWarning)
        }

function manageWellsWarningZone(){
wells.forEach((well) => {
wellWarningArea(well.x, well.y, 8)
removeDuplicateWellWarnings()
})
}
function getMiddleXCoordinate(element) {
  if (!(element instanceof Element)) {
    throw new Error("Invalid argument: element must be a DOM element.");
  }

  // Get the bounding rectangle of the element
  const rect = element.getBoundingClientRect();
  
  // Calculate the middle X coordinate
  const middleX = (rect.left + (rect.width / 2)) / gridSize;

  return middleX;
}
displaycheck()
function displaycheck(){
scoreAreaArray = []
let middleX = getMiddleXCoordinate(scoreDisplay)
        
scoreArea(middleX,1,4)
}






    function isNextItemTwoAway() {
        for (let i = 0; i < snake.length - 1; i++) {
            let current = snake[i];
            let next = snake[i + 1];
            if (!isTouchingOrOneAway(current)) {
                if (Math.abs(next.y - current.y) === 2) {
                    return false;
                }
            }
        }
        return true;
    }

    function shouldStopGravity() {
        const maxY = (canvas.height / gridSize) - 1;
        const maxX = (canvas.width / gridSize) - 1;

        for (let segment of snake) {
            if (segment.x === 0 || segment.x === maxX || segment.y === 0) {
                return true;
            }
        }

        let lastSegment = snake[snake.length - 1];
        if (lastSegment.y === maxY) {
            return true;
        }

        return false;
    }

    function isTouchingOrOneAway(segment) {
        const walls = mirrors.concat(obstacles, reflector);

        for (let wall of walls) {
            if (Math.abs(segment.x - wall.x) === 1 && Math.abs(segment.y - wall.y) === 2) {
                return true;
            }
        }

        return false;
    }

    function applyGravity() {
        const maxY = (canvas.height / gridSize) - 1;
        let disconnected = isNextItemTwoAway();
        let stopGravity = snake.some(segment => segment.y === maxY) || shouldStopGravity();
if (stopGravity){
fallingVelociy = 0
}
        physicsActive = false;
if (!physicsActive){
isStunnedFrFall = false
}
        if (GravityApplied && !stopGravity && disconnected) {
            isPossessed = false
            for (let i = 0; i < snake.length; i++) {
                if (!isTouchingOrOneAway(snake[i])) {
                    fallingVelociy += 1
                    if (inverted && direction !== 'up') {
                        snake[i].y += 1;
                        if (direction === 'down') {
                            snake[i].y += 1;
                        }
                    } else if (!inverted && direction !== 'down') {
                        snake[i].y += 1;
                        if (direction === 'up') {
                            snake[i].y += 1;
                        }
                    }
                } else {
                    physicsActive = true;  // Activate physics on collision
                }
            }
            for (let i = 0; i < snake2.length; i++) {
                if (!isTouchingOrOneAway(snake2[i])) {
                    if (inverted && direction !== 'up') {
                        snake2[i].y += 1;
                        if (direction === 'down') {
                            snake2[i].y += 1;
                        }
                    } else if (!inverted && direction !== 'down') {
                        snake2[i].y += 1;
                        if (direction === 'up') {
                            snake2[i].y += 1;
                        }
                    }
                } else {
                    physicsActive = true;  // Activate physics on collision
                }
            }
        }
if (physicsActive){
    applyRopePhysics()
}
        }
    

    function applyRopePhysics() {
        for (let i = 0; i < snake.length - 1; i++) {
            let segment = snake[i];
            let nextSegment = snake[i + 1];

            if (Math.abs(nextSegment.y - segment.y) > 1) {
                nextSegment.y = segment.y + Math.sign(nextSegment.y - segment.y);
            }

            if (Math.abs(nextSegment.x - segment.x) > 1) {
                nextSegment.x = segment.x + Math.sign(nextSegment.x - segment.x);
            }
        }

        for (let i = 0; i < snake2.length - 1; i++) {
            let segment = snake2[i];
            let nextSegment = snake2[i + 1];

            if (Math.abs(nextSegment.y - segment.y) > 1) {
                nextSegment.y = segment.y + Math.sign(nextSegment.y - segment.y);
            }

            if (Math.abs(nextSegment.x - segment.x) > 1) {
                nextSegment.x = segment.x + Math.sign(nextSegment.x - segment.x);
            }
        }
    }



        

    function catmullRomSpline(t, p0, p1, p2, p3) {
        let t2 = t * t;
        let t3 = t2 * t;
        let v0 = (p2 - p0) * 0.5;
        let v1 = (p3 - p1) * 0.5;
        let a = 2 * t3 - 3 * t2 + 1;
        let b = t3 - 2 * t2 + t;
        let c = t3 - t2;
        let d = -2 * t3 + 3 * t2;
        return a * p1 + b * v0 + c * v1 + d * p2;
    }

    function calculateRopePoints(nodes, numSegments) {
        let ropePoints = [];

        for (let i = 0; i < nodes.length - 1; i++) {
            let p0 = nodes[Math.max(i - 1, 0)];
            let p1 = nodes[i];
            let p2 = nodes[i + 1];
            let p3 = nodes[Math.min(i + 2, nodes.length - 1)];

            for (let t = 0; t <= 1; t += 1 / numSegments) {
                let interpolatedX = catmullRomSpline(t, p0.x, p1.x, p2.x, p3.x);
                let interpolatedY = catmullRomSpline(t, p0.y, p1.y, p2.y, p3.y);
                ropePoints.push({ x: interpolatedX, y: interpolatedY });
            }
        }

        return ropePoints;
    }

    
function kamekUpdate(){
            if (kamek.length > 1) {
    kamek.length = 1;
}
    if (kamek.length !== 0){
        applyStatus(1000, 'magic')
if (kamek[0].health === undefined){
    kamek[0].health = 100;
}
    }
if (kamek.length !== 0){
    const distance = Math.abs(snake[0].x - kamek[0].x) + Math.abs(snake[0].y - kamek[0].y);
      if (distance <= 5) {
    const randomX = Math.floor(Math.random() * (canvas.width / gridSize));
    const randomY = Math.floor(Math.random() * (canvas.height / gridSize));
    kamek[0].x = randomX;
    kamek[0].y = randomY;
        timezone = []
    kamekcanteleport = true
      if (shield === true){
       timezone = []
       generatePolygonCoordinates(kamek[0].x, kamek[0].y, 5, sideshield, timezone)
      }
      }
}
if (kamek.length === 0){
    timezone = []
}
}

function kamekMagic() {
    if (!isPaused) {
        // Determine the type of magic
        if ((Math.random() <= 0.2 && kamekcanteleport === false) && isParalyzed === false) {
            const magic = ['bolt', 'status', 'obstacle'];
            const randomIndex = Math.floor(Math.random() * magic.length);
            magictype = magic[randomIndex];
        } else if (sideshield <= 2){
            shield = false
            timezone = []
            const magic = ['port', 'obstacle'];
            const randomIndex = Math.floor(Math.random() * magic.length);
            magictype = magic[randomIndex];
        }else{
            const magic = ['port', 'wall', 'obstacle'];
            const randomIndex = Math.floor(Math.random() * magic.length);
            magictype = magic[randomIndex];
        }

        // Perform the action based on the type of magic
        if (magictype === 'bolt') {
            enemyshootmagic();
        } else if (magictype === 'port' && kamekcanteleport === true) {
            const randomX = Math.floor(Math.random() * (canvas.width / gridSize));
            const randomY = Math.floor(Math.random() * (canvas.height / gridSize));
            kamek[0].x = randomX;
            kamek[0].y = randomY;
            timezone = [];
        } else if (magictype === 'wall') {
            generatePolygonCoordinates(kamek[0].x, kamek[0].y, 5, sideshield, timezone);
            shield = true
            kamekcanteleport = false;
        } else if (magictype === 'status') {
            const status = ['paralyzed'];
            const randomIndex = Math.floor(Math.random() * status.length);
            const magicstatus = status[randomIndex];
            
           if (magicstatus === 'paralyzed') {
                isParalyzed = true;
                setTimeout(turnoffpara, 1000);
            }
        }else if (magictype === 'obstacle'){
// Assume obstacles and mirrors are defined arrays
const obstacles2 = [turrets, goombas];

// Generate a random index to select either the obstacles or mirrors array
const randomIndex = Math.floor(Math.random() * obstacles2.length);

// Select the array based on the random index
const spawner = obstacles2[randomIndex];

// Calculate random coordinates within the grid
const x = Math.floor(Math.random() * (canvas.width / gridSize));
let y = Math.floor(Math.random() * (canvas.height / gridSize));

// Add the new obstacle or mirror at the random coordinates
if (spawner !== goombas){
    if (spawner === turrets){
        if (turrets.length < 5){
        spawnTurrets(x,y)
        }
    }else{
        spawner.push({x:x,y:y})
        }
}else if(spawner === goombas){
    y -= 6
    if(y < 0){
        y = 6
    }
    spawnGoombas(x, y)
        }
        }
    }
}
function findClosestItem(snake, ...arrays) {
    // Helper function to calculate the Euclidean distance between two points
    function calculateDistancePossess(point1, point2) {
        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
    }

    const snakeHead = snake[0];
    let closestItem = null;
    let minDistance = Infinity;

    // Iterate over each array and their items
    arrays.forEach(array => {
        array.forEach(item => {
            const distance = calculateDistancePossess(snakeHead, item);
            if (distance < minDistance) {
                minDistance = distance;
                closestItem = item;
            }
        });
    });

    return closestItem
}
        function objectExistsInArrays(object, array) {
    return array.includes(object);
}
function possessionmove(){
let object = {x:3,y:3}
if (!choseobject){
    if (obstacles.length !== 0 ||  dynamicObstacles.length !== 0 || thwomps.length !== 0){
object = findClosestItem(snake, obstacles, dynamicObstacles, thwomps)
choseobject = true
}
}
   let exists = objectExistsInArrays(object, obstacles) || 
               objectExistsInArrays(object, thwomps) || 
               objectExistsInArrays(object, dynamicObstacles);

    if (choseobject && exists){
    if (snake[0].x < object.x) {
if(inverted === false){
direction = 'right'
}else{
direction = 'left'
}
}else if (snake[0].x > object.x) {
if(inverted === false){
direction = 'left'
}else{
direction = 'right';
}
        } 
          if (snake[0].y < object.y) {
         if(inverted === false){
direction = 'down'
}else{
direction = 'up'
}        } else if (snake[0].y > object.y) {
          if(inverted === false){
direction = 'up'
}else{
direction = 'down'
}
          }
}else if ((snake[0].x === object.x && snake[0].y === object.y) || !exists) {
    choseobject = false;
    isPossessed = false;
}
    if (obstacles.length === 0 ||  dynamicObstacles.length === 0 || thwomps.length === 0){
choseobject = false
isPossessed = false
    }
}
        
function cancelEffects(){
    isConfused = false
    isBurned = false
    isTaxed = false
}
function turnoffpara(){
    isParalyzed = false
}
function checkForEffects(){
    if (isConfused === true){
        applyStatus(1000, 'confuse')
    }
    if (isBurned === true && GravityApplied === false && isPaused === false){
        applyStatus(800, 'burn')
    }
    if (isTaxed === true){
        applyStatus(900, 'taxes')
    }
    if (controltype === 'mobile'){
    applyStatus(1000, 'well')
    }
}
function applyStatus(cooldown, effect){
    const currentTime = new Date().getTime();

    // Check if the cooldown period has elapsed
    if (currentTime - effectApplied < cooldown) {
        return; // Laser is still on cooldown
    } else {
if (isConfused === true && effect === 'confuse'){
    const directions = ['up', 'down', 'left', 'right']; // Possible directions
    const randomIndex = Math.floor(Math.random() * directions.length);
    direction = directions[randomIndex];
    effectApplied = currentTime
}
if (isBurned === true && effect === 'burn'){
    snake.pop()
    snake2.pop()
    effectApplied = currentTime
}
if(isTaxed === true && effect === 'taxes' && esnake[0].damage === false){
let tax = score * taxrate;
score -= tax;
effectApplied = currentTime
}
if (effect === 'well'){
  wellToggle()
effectApplied = currentTime
}
if (effect === 'magic' && kamek.length !== 0){
    kamekMagic()
    effectApplied = currentTime
}
        if (effect === 'gravity' && kamek.length === 0 && firelord.length === 0 && icelord.length === 0 && lightninglord.length === 0 && earthlord.length === 0 && ghostLord.length === 0 && chaosLord.length === 0) {
    GravityApplied = !GravityApplied;
            effectApplied = currentTime
        }
    }
}
document.addEventListener('keypress', function(event) {
    if (event.key === 'p') {
        pauseGame();
    }
});
                function createPortalAnimation(x, y, maxSize, duration) {

            const portalCenter = { x: x, y: y };
            let portalRadius = 0;
            const maxRadius = Math.min(maxSize, Math.hypot(canvas.width, canvas.height) / 2);

            let particles = [];
            const numParticles = 400;
            let particleRadius = 3;
            let startTime;

            // Initialize particles
            for (let i = 0; i < numParticles; i++) {
                particles.push({
                    angle: Math.random() * 2 * Math.PI,
                    distance: Math.random() * portalRadius,
                    speed: Math.random() * 0.05 + 0.01,
                    color: `hsl(${Math.random() * 60 + 60}, 100%, 50%)` // Greenish colors
                });
            }

            // Draw a single particle
            function drawParticle(particle) {
                ctx.beginPath();
                ctx.arc(
                    portalCenter.x + particle.distance * Math.cos(particle.angle),
                    portalCenter.y + particle.distance * Math.sin(particle.angle),
                    particleRadius,
                    0,
                    2 * Math.PI
                );
                ctx.fillStyle = particle.color;
                ctx.fill();
            }

            // Update particles
            function updateParticles(elapsedTime) {
                if (elapsedTime >= duration && portalRadius < 0) {
                    particles = []; // Clear particles array when duration elapses
                    return;
                }
                for (let particle of particles) {
                    particle.angle += particle.speed;
                    particle.distance += particle.speed * 10;

                    // Reset particle if it goes beyond max radius
                    if (particle.distance > portalRadius) {
                        particle.angle = Math.random() * 2 * Math.PI;
                        particle.distance = Math.random() * portalRadius;
                    }
                }
            }

            // Draw portal
            function drawPortal(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsedTime = timestamp - startTime;

                // Clear only the area within the radius of the portal
                ctx.save();
                ctx.beginPath();
                ctx.arc(portalCenter.x, portalCenter.y, portalRadius, 0, 2 * Math.PI);
                ctx.clip();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                // Update and draw particles
                updateParticles(elapsedTime);
                for (let particle of particles) {
                    drawParticle(particle);
                }

                // Draw portal effect
                const gradient = ctx.createRadialGradient(
                    portalCenter.x, portalCenter.y, portalRadius / 2,
                    portalCenter.x, portalCenter.y, portalRadius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
                gradient.addColorStop(0.5, 'rgba(0, 0, 255, 0.5)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');

                ctx.beginPath();
                ctx.arc(portalCenter.x, portalCenter.y, portalRadius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Update portal radius
                if (portalRadius < maxRadius && elapsedTime < duration) {
                    portalRadius += 2;
                } else if (portalRadius > 0) {
                    // Collapse the portal
                    portalRadius -= 2;
                }

                // Exit the function if both conditions are met
                if (portalRadius > 0 || elapsedTime < duration) {
                    requestAnimationFrame(drawPortal);
                }
            }

            // Start animation
            requestAnimationFrame(drawPortal);
        }

function spawnTurrets(x,y){
            createPortalAnimation((x* gridSize + gridSize/2), (y * gridSize + gridSize/2), 30, 500);
    setTimeout(() => {
    turrets.push({ x: x, y: y });
}, 250);

    }
function spawnGoombas(x,y){
            createPortalAnimation(x* gridSize, y * gridSize, 60, 1000);
    setTimeout(() => {
    goombas.push({ x: x, y: y });
}, 500);

    }
function getitem(enemytype){
switch (enemytype) {
        case 'taxform':
            return lightbrown;
    case 'antidote':
        return 'pink'
    case 'coin':
        return 'yellow'
    case 'welldelete':
        return welldeleter
               }
}
// Assume snake is an array representing the snake's body
// and itemIndex is the index of the item to be picked up

function pickUpItem(itemIndex) {
    // Define the canvas context and gridSize variables
    // Store the original colors of the snake segments
    const originalColors = snake.map(segment => segment.color);

    // Temporary color for the animation
    const tempColor = 'rgba(255, 255, 0, 1)'; // Solid yellow color

    // Create a wave effect by changing colors of the snake segments
    const animationInterval = setInterval(() => {
        // Change color of snake segments
        for (let i = 0; i < snake.length; i++) {
            // Calculate distance from itemIndex
            const distance = Math.abs(i - itemIndex);
            
            // Calculate color intensity based on distance
            const intensity = 1 - (distance / 10); // Adjust 10 to control the intensity
            
            // Set temporary color with reduced intensity
            snake[i].color = tempColor;
        }

        // Add a breaking wave effect at snake[0]
        snake[0].color = 'rgba(255, 255, 0, 1)'; // Set snake[0] to solid yellow
    // Additional wave breaking effect
            let deviceWidth, landscape = Math.abs(window.orientation) == 90;
        if (window.screen.width == 320) deviceWidth = landscape ? 480 : 320;
        else deviceWidth = window.screen[landscape ? "height" : "width"];
        let zoomFactor = deviceWidth / window.innerWidth;
        let antiZoomFactor = 1 / zoomFactor;

    const animationColor = 'rgba(255, 255, 0, 0.5)'; // Blue color with transparency
    let segmentSize = gridSize; // Adjust segment size based on anti-zoom factor
    let waveSize = 5; // Adjust the size of the wave based on anti-zoom factor
    let maxFrames = 8; // Number of frames for the eating animation

    let head = snake[0];
    let eatingAnimationFrames = Math.min(maxFrames, snake.length - 1);
    let eatenSegments = snake.slice(1, eatingAnimationFrames + 1);
    eatenSegments.forEach((segment, index) => {
        let animationFrame = eatingAnimationFrames - index;
        const segmentX = segment.x * gridSize;
        const segmentY = segment.y * gridSize;

        let originalOffset = waveSize * (maxFrames - animationFrame);
        var scaledOffset = Math.max(0, Math.ceil(originalOffset * antiZoomFactor));

        // Draw the wave-like effect
        ctx.fillStyle = animationColor;
        ctx.fillRect(segmentX, segmentY, segmentSize, segmentSize);
        ctx.fillRect(segmentX - scaledOffset, segmentY, segmentSize, segmentSize);
        ctx.fillRect(segmentX + scaledOffset, segmentY, segmentSize, segmentSize);
        ctx.fillRect(segmentX, segmentY - scaledOffset, segmentSize, segmentSize);
        ctx.fillRect(segmentX, segmentY + scaledOffset, segmentSize, segmentSize);

        // Draw the original segment
        ctx.fillRect(segmentX, segmentY, segmentSize, segmentSize);
    });

    // Reset snake color after eating animation
    originalSnakeColor = '#00FF00';

        // After the animation duration, restore original colors and stop the animation
        setTimeout(() => {
            // Restore original colors
            snake.forEach((segment, index) => {
                segment.color = originalColors[index];
            });

            // Stop the animation interval
            clearInterval(animationInterval);

 }, 1000); // Adjust this time to control animation duration
    }, 100); // Adjust this time to control animation speed

        }
// Ensure each turret has a lastFired property

function ManageTurrets() {
  turrets.forEach((turret) => {
  if (turret.lastFired === undefined) {
    turret.lastFired = 0; // Initialize with a timestamp indicating it hasn't fired yet
  }
}); 
    const now = Date.now(); // Current timestamp

  if (turrets.length !== 0) {
    turrets.forEach((well) => {
      const distance = Math.abs(snake[0].x - well.x) + Math.abs(snake[0].y - well.y);

      // Check if the turret is within range and if it can fire
      if (distance <= 5 && (now - well.lastFired >= 1000)) {
        shootWaveOfProjectiles(well.x * gridSize, well.y * gridSize, 1, 1, 0.5,'purple', obstacles, dynamicObstacles, gridSize,'down', 20, 70, true, 3,false, 20,1, true,kamek);

        // Update the last fired timestamp
        well.lastFired = now;
      }
    });
  } else {
    return;
  }

  // Limit the number of turrets to 5
  if (turrets.length > 5) {
    turrets.length = 5;
  }
}
        let lordcanspawn = true
   let lords = [firelord, lightninglord, icelord, earthlord]; // Possible directions


function checkDistance(snake) {
    wells.forEach((well) => {
      const distance = Math.abs(snake[0].x - well.x) + Math.abs(snake[0].y - well.y);
      if (distance <= wellStrength) {
if (snake[0].x < well.x) {
if(inverted === false){
direction = 'right'
}else{
direction = 'left'
}
}else if (snake[0].x > well.x) {
if(inverted === false){
direction = 'left'
}else{
direction = 'right';
}
        } 
          if (snake[0].y < well.y) {
         if(inverted === false){
direction = 'down'
}else{
direction = 'up'
}        } else if (snake[0].y > well.y) {
          if(inverted === false){
direction = 'up'
}else{
direction = 'down'
}
          }
      }
    });
}

function getenemycolor(enemytype){
switch (enemytype) {
        case 'base':
            return  '#990147'
        case 'IRS':
            return 'lightgrey';

       }
}
function venomreset(){
    symbiote = []
}
function Dieenemy(){
esnake = []
}
function generatePolygonCoordinates(x, y, length, sides, coordinates) {
    // Calculate the angle between each side
    const angleBetweenSides = (2 * Math.PI) / sides;

    // Iterate over each side
    for (let i = 0; i < sides; i++) {
        // Calculate the angle of the current side
        const angle = i * angleBetweenSides;
        const nextAngle = (i + 1) * angleBetweenSides;

        // Calculate the coordinates of the current vertex
        const currentX = Math.round(x + length * Math.cos(angle));
        const currentY = Math.round(y + length * Math.sin(angle));

        // Calculate the coordinates of the next vertex
        const nextX = Math.round(x + length * Math.cos(nextAngle));
        const nextY = Math.round(y + length * Math.sin(nextAngle));

        // Generate straight line between current and next vertex
        generateStraightLineCoordinates(currentX, currentY, nextX, nextY, coordinates);
    }
}

function generateStraightLineCoordinates(startX, startY, endX, endY, coordinates) {
    // Calculate the distance between the start and end points
    const dx = endX - startX;
    const dy = endY - startY;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));

    // Generate coordinates along the line using linear interpolation
    for (let i = 0; i <= steps; i++) {
        const x = Math.round(startX + dx * (i / steps));
        const y = Math.round(startY + dy * (i / steps));
        coordinates.push({ x, y });
        polygons.push({ x, y })
    }
}


function invertAngle(angle) {
    // Ensure angle is within the range [0, 360)
    angle %= 360;
    // Calculate the inverse angle
    let inverseAngle = (180 - angle) % 360;
    // Ensure the result is positive
    if (inverseAngle < 0) {
        inverseAngle += 360;
    }
    return inverseAngle;
}


function formshape(x, y, length, sides, coordinates){
    let fill = 1 
    for (let i = 0; i < length; i++) {
   generatePolygonCoordinates(x, y, fill, sides, coordinates) 
    fill += 1
    }
    }

function formrandomshape(length){
    let sides = 2
    let array = []
    const x2 = Math.floor(Math.random() * (canvas.width / gridSize));
    const y2 = Math.floor(Math.random() * (canvas.height / gridSize));
    const sidenumber = [3, 4, 5, 6, 7, 8]; // Possible directions
    const sideIndex = Math.floor(Math.random() * sidenumber.length);
    sides = sidenumber[sideIndex];
    const arrays = [obstacles, mirrors]; // Possible directions
    const arrayIndex = Math.floor(Math.random() * arrays.length);
    array = arrays[arrayIndex];
    formshape(x2, y2, length, sides, array)
}
function checkAndSplice(polygons, mirrors) {
    // Filter out mirrors that have matching coordinates in the polygons array
    const filteredMirrors = mirrors.filter(mirror => {
        return !polygons.some(polygon => {
            return mirror.x === polygon.x && mirror.y === polygon.y;
        });
    });
    
    // Update the original mirrors array with the filtered mirrors
    mirrors.length = 0; // Clear the original array
    Array.prototype.push.apply(mirrors, filteredMirrors); // Add filtered mirrors back to the original array
}

function spawnvenom(type){
symbiote = Array.from({ length: snake.length }, (_, index) => ({ x: 10, y: 10 - index, type: type }));
}


function wellToggle(){
    isGravityWellActive = !isGravityWellActive
}
        
function calculateGameProbability(score, foodCounts) {
        const totalFoods = Object.values(foodCounts).reduce((acc, count) => acc + count, 0);
    const foodTypeProbabilities = {
        rare: foodCounts.rare / totalFoods,
        special: foodCounts.special / totalFoods,
        common: foodCounts.common / totalFoods
    };

    // Probability of an obstacle spawning and a specific food type spawning
    const gameProbability = foodTypeProbabilities.rare * foodTypeProbabilities.special * foodTypeProbabilities.common;
    return gameProbability;
}

// Example usage:

let foodCounts = {
    rare: 1, // Example count of rare foods
    special: 10, // Example count of special foods
    common: 3 // Example count of common foods
};
const probability = calculateGameProbability

function symbioteAi(symbiotes, canvas, gridSize){
      let startNode = { x: symbiote[0].x, y: symbiote[0].y };
    // End node is the head of the player snake (snake[0])
    let endNode = { x: snake[0].x, y: snake[0].y };

    // Implement A* algorithm to find the shortest path from startNode to endNode
    let path = aStarPathfinding(startNode, endNode, canvas, gridSize);

    // Move the enemy snake towards the next node in the path
    if (path.length > 1) {
        // Next node in the path
        let nextNode = path[1];
        // Move towards the next node
        if (nextNode.x < symbiote[0].x) {
            // Move left
            symbiote[0].x = (symbiote[0].x - enemymovementspeed + canvas.width / gridSize) % (canvas.width / gridSize);
        } else if (nextNode.x > symbiote[0].x) {
            // Move right
            symbiote[0].x = (symbiote[0].x + enemymovementspeed) % (canvas.width / gridSize);
        } else if (nextNode.y < symbiote[0].y) {
            // Move up
            symbiote[0].y = (symbiote[0].y - enemymovementspeed + canvas.height / gridSize) % (canvas.height / gridSize);
        } else if (nextNode.y > symbiote[0].y) {
            // Move down
            symbiote[0].y = (symbiote[0].y + enemymovementspeed) % (canvas.height / gridSize);
        }
    }

    // Move the body of the enemy snake to follow the head
    for (let i = symbiote.length - 1; i > 0; i--) {
        symbiote[i].x = symbiote[i - 1].x;
        symbiote[i].y = symbiote[i - 1].y;
    }
}

// Define the enemy AI function with A* pathfinding
function enemyAI(esnake, canvas, gridSize) {
    // A* pathfinding
    // Start node is the head of the enemy snake
    let startNode = { x: esnake[0].x, y: esnake[0].y };
    // End node is the head of the player snake (snake[0])
    let endNode = { x: snake[0].x, y: snake[0].y };

    // Implement A* algorithm to find the shortest path from startNode to endNode
    let path = aStarPathfinding(startNode, endNode, canvas, gridSize);

    // Move the enemy snake towards the next node in the path
    if (path.length > 1) {
        // Next node in the path
        let nextNode = path[1];
        // Move towards the next node
        if (nextNode.x < esnake[0].x) {
            // Move left
            esnake[0].x = (esnake[0].x - enemymovementspeed + canvas.width / gridSize) % (canvas.width / gridSize);
        } else if (nextNode.x > esnake[0].x) {
            // Move right
            esnake[0].x = (esnake[0].x + enemymovementspeed) % (canvas.width / gridSize);
        } else if (nextNode.y < esnake[0].y) {
            // Move up
            esnake[0].y = (esnake[0].y - enemymovementspeed + canvas.height / gridSize) % (canvas.height / gridSize);
        } else if (nextNode.y > esnake[0].y) {
            // Move down
            esnake[0].y = (esnake[0].y + enemymovementspeed) % (canvas.height / gridSize);
        }
    }

    // Move the body of the enemy snake to follow the head
    for (let i = esnake.length - 1; i > 0; i--) {
        esnake[i].x = esnake[i - 1].x;
        esnake[i].y = esnake[i - 1].y;
    }
}

// A* pathfinding algorithm
function aStarPathfinding(startNode, endNode, canvas, gridSize) {
    // Define grid dimensions
    let gridWidth = canvas.width / gridSize;
    let gridHeight = canvas.height / gridSize;

    // Initialize open and closed lists
    let openList = [];
    let closedList = [];

    // Initialize start node
    startNode.g = 0;
    startNode.h = heuristic(startNode, endNode);
    startNode.f = startNode.g + startNode.h;
    openList.push(startNode);

    // Start A* algorithm
    while (openList.length > 0) {
        // Find node with lowest f value in the open list
        let currentNode = openList[0];
        for (let i = 1; i < openList.length; i++) {
            if (openList[i].f < currentNode.f || (openList[i].f === currentNode.f && openList[i].h < currentNode.h)) {
                currentNode = openList[i];
            }
        }

        // Move current node from open to closed list
        openList = openList.filter(node => node !== currentNode);
        closedList.push(currentNode);

        // Check if current node is the goal
        if (currentNode.x === endNode.x && currentNode.y === endNode.y) {
            return reconstructPath(currentNode);
        }

        // Generate neighbors of current node
        let neighbors = [];
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                if (dx === 0 && dy === 0) continue; // Skip current node
                let neighborX = (currentNode.x + dx + gridWidth) % gridWidth;
                let neighborY = (currentNode.y + dy + gridHeight) % gridHeight;
                let neighbor = { x: neighborX, y: neighborY };
                neighbors.push(neighbor);
            }
        }

        // Process each neighbor
        for (let neighbor of neighbors) {
            // Skip neighbor if it's in the closed list or is an obstacle
            if (closedList.find(node => node.x === neighbor.x && node.y === neighbor.y)) continue;

            // Calculate tentative g score for neighbor
            let tentativeG = currentNode.g + 1; // Assuming each move has a cost of 1

            // Check if neighbor is already in the open list
            let existingNode = openList.find(node => node.x === neighbor.x && node.y === neighbor.y);
            if (!existingNode || tentativeG < existingNode.g) {
                if (!existingNode) {
                    // Add neighbor to open list
                    neighbor.g = tentativeG;
                    neighbor.h = heuristic(neighbor, endNode);
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = currentNode;
                    openList.push(neighbor);
                } else {
                    // Update neighbor in open list with new g score
                    existingNode.g = tentativeG;
                    existingNode.f = existingNode.g + existingNode.h;
                    existingNode.parent = currentNode;
                }
            }
        }
    }

    // If open list is empty and goal is not found, return an empty path
    return [];
}

// Calculate heuristic value (Manhattan distance)
function heuristic(node, target) {
    return Math.abs(node.x - target.x) + Math.abs(node.y - target.y);
}

// Reconstruct path from goal node to start node
function reconstructPath(goalNode) {
    let path = [];
    let currentNode = goalNode;
    while (currentNode) {
        path.unshift(currentNode);
        currentNode = currentNode.parent;
    }
    return path;
}


function isCollidingWithBody(x, y) {
    // Loop through each segment of the snake's body
    for (let i = 1; i < snake.length; i++) {
        // Check if the specified position matches the position of any segment of the snake's body
        if (snake[i].x === x && snake[i].y === y) {
            // If a match is found, return true indicating collision
            return true;
        }
    }
    // If no match is found, return false indicating no collision
    return false;
}

function drawPolygon(x, y, length, sides, color) {
        ctx.beginPath();
        ctx.moveTo(x + length * Math.cos(0), y + length * Math.sin(0));
        for (let i = 1; i <= sides; i++) {
            ctx.lineTo(x + length * Math.cos(i * (2 * Math.PI) / sides), y + length * Math.sin(i * (2 * Math.PI) / sides));
        }
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
    }

function drawFlatPolygon(x, y, size, sides, color) {
    ctx.fillStyle = color;
    ctx.beginPath();

    if (sides === 3) {
        // Equilateral triangle pointing upwards
        ctx.moveTo(x, y - size / Math.sqrt(3)); // Top vertex
        ctx.lineTo(x - size / 2, y + size / (2 * Math.sqrt(3))); // Bottom left vertex
        ctx.lineTo(x + size / 2, y + size / (2 * Math.sqrt(3))); // Bottom right vertex
    } else if (sides === 4) {
        // Square
        ctx.moveTo(x - size / 2, y - size / 2); // Top left
        ctx.lineTo(x + size / 2, y - size / 2); // Top right
        ctx.lineTo(x + size / 2, y + size / 2); // Bottom right
        ctx.lineTo(x - size / 2, y + size / 2); // Bottom left
    } else if (sides === 5) {
        // Pentagon
        ctx.moveTo(x, y - size); // Top vertex
        ctx.lineTo(x - size * Math.cos(Math.PI / 10), y - size * Math.sin(Math.PI / 10)); // Top left
        ctx.lineTo(x - size * Math.cos(Math.PI / 2.5), y + size * Math.sin(Math.PI / 10)); // Bottom left
        ctx.lineTo(x + size * Math.cos(Math.PI / 2.5), y + size * Math.sin(Math.PI / 10)); // Bottom right
        ctx.lineTo(x + size * Math.cos(Math.PI / 10), y - size * Math.sin(Math.PI / 10)); // Top right
    } else {
        // General case for regular polygons, centered at (x, y)
        let angleIncrement = (Math.PI * 2) / sides;
        ctx.moveTo(x + size * Math.cos(0), y + size * Math.sin(0));
        for (let i = 1; i < sides; i++) {
            ctx.lineTo(x + size * Math.cos(i * angleIncrement), y + size * Math.sin(i * angleIncrement));
        }
    }

    ctx.closePath();
    ctx.fill();
}

function drawGoomba(gx, gy) {
    // Scale size
    let x = gx * gridSize;
    let y = gy * gridSize;
    let size = gridSize;
    const headHeight = size * 2;
    const bodyHeight = size;
    const bodyWidth = size * 1.2;
    const eyeRadius = size * 0.3;
    const pupilRadius = size * 0.1;
    const footRadius = size * 0.6;
    const browWidth = size * 0.6;
    const browHeight = size * 0.1;
    const mouthWidth = size * 0.8;
    const mouthHeight = size * 0.15;

    // Draw the body (a rectangle)
    ctx.fillStyle = "#f1e0c6";
    ctx.fillRect(x - bodyWidth / 2, y + headHeight - (headHeight / 8), bodyWidth * 1.5, bodyHeight * 1.2);

    // Draw the head (a hexagon)
    ctx.fillStyle = "#b5651d";
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + size * 1.5, y + headHeight / 3);
    ctx.lineTo(x + size * 1.5, y + headHeight);
    ctx.lineTo(x, y + headHeight * 1.25);
    ctx.lineTo(x - size * 1.5, y + headHeight);
    ctx.lineTo(x - size * 1.5, y + headHeight / 3);
    ctx.closePath();
    ctx.fill();

    // Draw the feet (two circles)
    ctx.fillStyle = "#8b4513";
    ctx.beginPath();
    ctx.arc(x - size * 1, y + headHeight + bodyHeight + footRadius - (headHeight / 2), footRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + size * 1, y + headHeight + bodyHeight + footRadius - (headHeight / 2), footRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw the eyes (two circles and black pupils)
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(x - size * 0.5, y + headHeight / 2, eyeRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + size * 0.5, y + headHeight / 2, eyeRadius, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.arc(x - size * 0.5, y + headHeight / 2, pupilRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + size * 0.5, y + headHeight / 2, pupilRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw the eyebrows (two rectangles)
    ctx.fillStyle = "#000000";
    ctx.fillRect(x - size * 0.8, y + headHeight / 3.5, browWidth, browHeight);
    ctx.fillRect(x + size * 0.2, y + headHeight / 3.5, browWidth, browHeight);

    // Draw the mouth (a rectangle)
    ctx.fillStyle = "#000000";
    ctx.fillRect(x - mouthWidth / 2, y + headHeight * 0.8, mouthWidth, mouthHeight);

    // Calculate bounding box coordinates
    const boundingBoxX = x - size * 1.5;
    const boundingBoxY = y;
    const boundingBoxWidth = size * 3;
    const boundingBoxHeight = headHeight + bodyHeight + footRadius

}

// Function to check if a point collides with the bounding box
function isPointInGoombaBoundingBox(px, py, gx, gy) {
    let x = gx * gridSize;
    let y = gy * gridSize;
    let size = gridSize;
    const headHeight = size * 2;
    const bodyHeight = size;
    const footRadius = size * 0.6;

    const boundingBoxX = x - size * 1.5;
    const boundingBoxY = y;
    const boundingBoxWidth = size * 3;
    const boundingBoxHeight = headHeight + bodyHeight + footRadius

    return (
        px >= boundingBoxX &&
        px <= boundingBoxX + boundingBoxWidth &&
        py >= boundingBoxY &&
        py <= boundingBoxY + boundingBoxHeight
    );
}
let GoombaCollision


function getBoundingBox(polygon) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    for (let i = 0; i < polygon.length; i++) {
        let x = polygon[i][0];
        let y = polygon[i][1];
        
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
    }
    
    return { minX, minY, maxX, maxY };
}

// Function to check if a point is within a bounding box
function isPointInBox(pointX, pointY, box) {
    return pointX >= box.minX && pointX <= box.maxX && pointY >= box.minY && pointY <= box.maxY;
}

// Function to get Kamek's bounding box
function getKamekBoundingBox(x, y, gridSize) {
    // Calculate vertices of Kamek's polygons
    let robePolygon = [
        [x, y + gridSize + gridSize],
        [x + gridSize + (gridSize / 2), y + gridSize + gridSize],
        [x + gridSize + (gridSize / 2), y],
        [x - gridSize - (gridSize / 2), y],
        [x - gridSize - (gridSize / 2), y + gridSize + gridSize]
    ];

    let hatPolygon = [
        [x, y - gridSize / Math.sqrt(3)],
        [x - gridSize / 2, y + gridSize / (2 * Math.sqrt(3))],
        [x + gridSize / 2, y + gridSize / (2 * Math.sqrt(3))]
    ];

    // Combine all vertices
    let allVertices = robePolygon.concat(hatPolygon);

    // Get bounding box
    return getBoundingBox(allVertices);
}

// Function to check if a point is colliding with Kamek
function isCollidingWithKamek(kamekX, kamekY, gridSize, pointX, pointY) {
    // Get Kamek's bounding box
    let kamekBoundingBox = getKamekBoundingBox(kamekX, kamekY, gridSize);
    
    // Check if the point is within Kamek's bounding box
    return isPointInBox(pointX, pointY, kamekBoundingBox);
}
function drawKamek(x, y){
    // Scale the coordinates by gridSize
    x = x * gridSize;
    y = y * gridSize;

    // Draw the polygons (hat and robe)
    drawFlatPolygon(x, y + gridSize + gridSize, gridSize + (gridSize / 2), 5, 'blue');
    drawPolygon(x, y + gridSize, gridSize, 4, 'gold');
    drawFlatPolygon(x, y, gridSize, 3, 'blue');
    drawPolygon(x + gridSize, y + gridSize + gridSize, (gridSize / 2), 4, 'gold');
    drawPolygon(x - gridSize, y + gridSize + gridSize, (gridSize / 2), 4, 'gold');
    
    // Calculate eye positions relative to the robe polygon
    let eyeBaseX = x; // Center of the robe
    let eyeBaseY = y + gridSize; // Same y-level as the robe

    // Draw the eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(eyeBaseX - gridSize / 4, eyeBaseY - gridSize / 2, gridSize / 4, 0, Math.PI * 2); // Left eye
    ctx.arc(eyeBaseX + gridSize / 4, eyeBaseY - gridSize / 2, gridSize / 4, 0, Math.PI * 2); // Right eye
    ctx.fill();

    // Draw the pupils
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(eyeBaseX - gridSize / 4, eyeBaseY - gridSize / 2, gridSize / 8, 0, Math.PI * 2); // Left pupil
    ctx.arc(eyeBaseX + gridSize / 4, eyeBaseY - gridSize / 2, gridSize / 8, 0, Math.PI * 2); // Right pupil
    ctx.fill();
}
        function drawChaosLord(x, y) {
    // Scale the coordinates by gridSize
    x = x * gridSize;
    y = y * gridSize;

    // Draw the body (a purple pentagon)
    drawFlatPolygon(x, y, gridSize, 5, 'purple');

    // Draw the head (a green triangle) connected to the body
    drawFlatPolygon(x, y - gridSize * 0.8, gridSize, 3, 'green');

    // Draw the eyes (two white circles) on the head
    let eyeRadius = gridSize * 0.2;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw the pupils (two black circles)
    let pupilRadius = gridSize * 0.1;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw the mouth (a black rectangle) on the head
    let mouthWidth = gridSize * 0.8;
    let mouthHeight = gridSize * 0.15;
    ctx.fillStyle = 'black';
    ctx.fillRect(x - mouthWidth / 2, y + gridSize * 0.8, mouthWidth, mouthHeight);

    // Draw the robe (a black rectangle) covering the lower part of the body
    ctx.fillStyle = 'black';
    ctx.fillRect(x - gridSize * 0.7, y, gridSize * 1.4, gridSize);

    // Draw the arms (small black rectangles) connected to the body
    let armWidth = gridSize * 0.2;
    let armHeight = gridSize * 0.6;
    ctx.fillRect(x - gridSize * 0.9, y - gridSize * 0.2, armWidth, armHeight);
    ctx.fillRect(x + gridSize * 0.7, y - gridSize * 0.2, armWidth, armHeight);

    // Draw the feet (black rectangles) touching the body and robe
    let footWidth = gridSize * 0.4;
    let footHeight = gridSize * 0.4;
    ctx.fillRect(x - gridSize * 0.5, y + gridSize * 0.8, footWidth, footHeight);
    ctx.fillRect(x + gridSize * 0.1, y + gridSize * 0.8, footWidth, footHeight);

    // Draw a lightgray stroke around the ChaosLord
    ctx.strokeStyle = 'lightgray';
    ctx.lineWidth = gridSize * 0.1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y + gridSize);
    ctx.stroke();

    // Bounding box calculation
    let boundingBox = {
        xMin: x - gridSize * 0.9,
        yMin: y - gridSize * 1.4,
        xMax: x + gridSize * 0.9,
        yMax: y + gridSize * 1.2
    };

    return boundingBox;
}
       
let chaosAngle = 0;
let movingchaosMagic = 0;
let chaosMagic = 0;
let chaosLordInMotion = false;
let chaosLordBoundingBox = drawChaosLord(5, 5);
let canTeleport = false;
  function manageChaosLord() {
    if (chaosLord.length !== 0) {
        applyStatus(1000, 'magic');
        const functions = [
    lightningArea,
    ghostArea,
    earthArea,
    iceArea,
    addLavaArea
];

// Choose a random function
const randomFunction = functions[Math.floor(Math.random() * functions.length)];

randomFunction(chaosLord[0].x, chaosLord[0].y, 2, 1.8);
        if (chaosLord[0].health === undefined) {
            chaosLord[0].health = 100;
        }

        if (chaosLordInMotion === false) {
            const targetX = snake[0].x * gridSize;
            const targetY = snake[0].y * gridSize;
            chaosAngle = Math.atan2(targetY - chaosLord[0].y * gridSize, targetX - chaosLord[0].x * gridSize);
        }

        let velocityX = Math.cos(chaosAngle);
        let velocityY = Math.sin(chaosAngle);

        if (chaosLord.length > 1) {
            chaosLord.length = 1;
        }


        if (chaosLordInMotion === false) {
            const magicOptions = ['launch', 'bolt', 'port']
            const randomIndex = Math.floor(Math.random() * magicOptions.length);
            chaosMagic = magicOptions[randomIndex];
        }
        if (chaosLordInMotion === true) {
            const magicOptions = ['launch', 'bolt', 'port', 'bolt', 'port']
            const randomIndex = Math.floor(Math.random() * magicOptions.length);
            movingchaosMagic = magicOptions[randomIndex];
        }

        if ((chaosMagic === 'launch') || movingchaosMagic === 'launch' && chaosLordInMotion ) {
            if (movingchaosMagic === 'launch' && chaosLordInMotion){
                targetX = snake[0].x * gridSize;
             targetY = snake[0].y * gridSize;
            chaosAngle = Math.atan2(targetY - chaosLord[0].y * gridSize, targetX - chaosLord[0].x * gridSize);
            }

                
            chaosLord[0].x += velocityX;
            chaosLord[0].y += velocityY;
            chaosLordInMotion = true;
            chaosLordBoundingBox = drawChaosLord(chaosLord[0].x, chaosLord[0].y);

            if (chaosLordBoundingBox.xMin < 0 || chaosLordBoundingBox.yMin < 0 ||
                chaosLordBoundingBox.xMax > canvas.width || chaosLordBoundingBox.yMax > canvas.height) {
                chaosLordInMotion = false;
            }
        } else if ((chaosMagic === 'bolt' && !chaosLordInMotion ) || movingchaosMagic === 'bolt' && chaosLordInMotion ) {
            canTeleport = true
            shootWaveOfProjectiles(chaosLord[0].x * gridSize, chaosLord[0].y * gridSize, 1, 1, 0.5, 'blue', obstacles, dynamicObstacles, gridSize, 'down', 20, 70, true, 3, false, 20, 1, true, chaosLord);
        } else if ((chaosMagic === 'port' && !chaosLordInMotion  && canTeleport === true) || movingchaosMagic === 'port' && chaosLordInMotion  && canTeleport === true) {
            const randomX = Math.floor(Math.random() * (canvas.width / gridSize));
            const randomY = Math.floor(Math.random() * (canvas.height / gridSize));
            chaosLord[0].x = randomX;
            chaosLord[0].y = randomY;
        } 
            }
        }
    function drawEarthLord(x, y) {
    // Scale the coordinates by gridSize
    x = x * gridSize;
    y = y * gridSize;

    // Draw the body (a red pentagon)
    drawFlatPolygon(x, y, gridSize, 5, 'brown');

    // Draw the head (an orange triangle) connected to the body
    drawFlatPolygon(x, y - gridSize * 0.8, gridSize, 3, lightbrown);

    // Draw the crown (a yellow pentagon) on the head
    
    // Draw the eyes (two white circles) on the head
    let eyeRadius = gridSize * 0.2;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw the pupils (two black circles)
    let pupilRadius = gridSize * 0.1;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.fill();

let mouthWidth = gridSize * 0.8;
    let mouthHeight = gridSize * 0.15;
    ctx.fillStyle = 'black';
    ctx.fillRect(x, y, mouthWidth, mouthHeight);


    ctx.fillStyle = 'black';
    
ctx.fillRect(x - mouthWidth / 2, y + gridSize * 0.8, mouthWidth, mouthHeight);
    
    // Draw the robe (a black rectangle) covering the lower part of the body
    ctx.fillStyle = 'black';
    ctx.fillRect(x - gridSize * 0.7, y, gridSize * 1.4, gridSize);

ctx.strokeStyle = 'brown';
    ctx.lineWidth = gridSize * 0.1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y + gridSize);
    ctx.stroke();
        
    // Draw the arms (small black rectangles) connected to the body
    let armWidth = gridSize * 0.2;
    let armHeight = gridSize * 0.6;
    ctx.fillRect(x - gridSize * 0.9, y - gridSize * 0.2, armWidth, armHeight);
    ctx.fillRect(x + gridSize * 0.7, y - gridSize * 0.2, armWidth, armHeight);

    // Draw the feet (black rectangles) touching the body and robe
    let footWidth = gridSize * 0.4;
    let footHeight = gridSize * 0.4;
    ctx.fillRect(x - gridSize * 0.5, y + gridSize * 0.8, footWidth, footHeight);
    ctx.fillRect(x + gridSize * 0.1, y + gridSize * 0.8, footWidth, footHeight);

    // Bounding box calculation
    let boundingBox = {
        xMin: x - gridSize * 0.9,
        yMin: y - gridSize * 1.4,
        xMax: x + gridSize * 0.9,
        yMax: y + gridSize * 1.2
    };

    


    return boundingBox;
}

function drawFireLord(x, y) {
    // Scale the coordinates by gridSize
    x = x * gridSize;
    y = y * gridSize;

    // Draw the body (a red pentagon)
    drawFlatPolygon(x, y, gridSize, 5, 'red');

    // Draw the head (an orange triangle) connected to the body
    drawFlatPolygon(x, y - gridSize * 0.8, gridSize, 3, 'orange');

    // Draw the crown (a yellow pentagon) on the head
    drawFlatPolygon(x, y - gridSize * 1.4, gridSize * 0.5, 5, 'yellow');

    // Draw the eyes (two white circles) on the head
    let eyeRadius = gridSize * 0.2;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw the pupils (two black circles)
    let pupilRadius = gridSize * 0.1;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.fill();

let mouthWidth = gridSize * 0.8;
    let mouthHeight = gridSize * 0.15;
    ctx.fillStyle = 'black';
    ctx.fillRect(x, y, mouthWidth, mouthHeight);


    ctx.fillStyle = 'black';
    
ctx.fillRect(x - mouthWidth / 2, y + gridSize * 0.8, mouthWidth, mouthHeight);
    
    // Draw the robe (a black rectangle) covering the lower part of the body
    ctx.fillStyle = 'black';
    ctx.fillRect(x - gridSize * 0.7, y, gridSize * 1.4, gridSize);

ctx.strokeStyle = 'orange';
    ctx.lineWidth = gridSize * 0.1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y + gridSize);
    ctx.stroke();
        
    // Draw the arms (small black rectangles) connected to the body
    let armWidth = gridSize * 0.2;
    let armHeight = gridSize * 0.6;
    ctx.fillRect(x - gridSize * 0.9, y - gridSize * 0.2, armWidth, armHeight);
    ctx.fillRect(x + gridSize * 0.7, y - gridSize * 0.2, armWidth, armHeight);

    // Draw the feet (black rectangles) touching the body and robe
    let footWidth = gridSize * 0.4;
    let footHeight = gridSize * 0.4;
    ctx.fillRect(x - gridSize * 0.5, y + gridSize * 0.8, footWidth, footHeight);
    ctx.fillRect(x + gridSize * 0.1, y + gridSize * 0.8, footWidth, footHeight);

    // Bounding box calculation
    let boundingBox = {
        xMin: x - gridSize * 0.9,
        yMin: y - gridSize * 1.4,
        xMax: x + gridSize * 0.9,
        yMax: y + gridSize * 1.2
    };

    


    return boundingBox;
}

function drawLightningLord(x, y) {
    // Scale the coordinates by gridSize
    x = x * gridSize;
    y = y * gridSize;

    // Draw the body (a red pentagon)
    drawFlatPolygon(x, y, gridSize, 5, electriccolor);

    // Draw the head (an orange triangle) connected to the body
    drawFlatPolygon(x, y - gridSize * 0.8, gridSize, 3, 'blue');

    // Draw the crown (a yellow pentagon) on the head
    
    // Draw the eyes (two white circles) on the head
    let eyeRadius = gridSize * 0.2;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw the pupils (two black circles)
    let pupilRadius = gridSize * 0.1;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.fill();

let mouthWidth = gridSize * 0.8;
    let mouthHeight = gridSize * 0.15;
    ctx.fillStyle = 'black';
    ctx.fillRect(x, y, mouthWidth, mouthHeight);


    ctx.fillStyle = 'black';
    
ctx.fillRect(x - mouthWidth / 2, y + gridSize * 0.8, mouthWidth, mouthHeight);
    
    // Draw the robe (a black rectangle) covering the lower part of the body
    ctx.fillStyle = 'black';
    ctx.fillRect(x - gridSize * 0.7, y, gridSize * 1.4, gridSize);

ctx.strokeStyle = electriccolor
    ctx.lineWidth = gridSize * 0.1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y + gridSize);
    ctx.stroke();
        
    // Draw the arms (small black rectangles) connected to the body
    let armWidth = gridSize * 0.2;
    let armHeight = gridSize * 0.6;
    ctx.fillRect(x - gridSize * 0.9, y - gridSize * 0.2, armWidth, armHeight);
    ctx.fillRect(x + gridSize * 0.7, y - gridSize * 0.2, armWidth, armHeight);

    // Draw the feet (black rectangles) touching the body and robe
    let footWidth = gridSize * 0.4;
    let footHeight = gridSize * 0.4;
    ctx.fillRect(x - gridSize * 0.5, y + gridSize * 0.8, footWidth, footHeight);
    ctx.fillRect(x + gridSize * 0.1, y + gridSize * 0.8, footWidth, footHeight);

    // Bounding box calculation
    let boundingBox = {
        xMin: x - gridSize * 0.9,
        yMin: y - gridSize * 1.4,
        xMax: x + gridSize * 0.9,
        yMax: y + gridSize * 1.2
    };

    


    return boundingBox;
}

function drawIceLord(x, y) {
    // Scale the coordinates by gridSize
    x = x * gridSize;
    y = y * gridSize;

    // Draw the body (a red pentagon)
    drawFlatPolygon(x, y, gridSize, 5, icecolor);

    // Draw the head (an orange triangle) connected to the body
    drawFlatPolygon(x, y - gridSize * 0.8, gridSize, 3, 'blue');

    // Draw the crown (a yellow pentagon) on the head
    
    // Draw the eyes (two white circles) on the head
    let eyeRadius = gridSize * 0.2;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw the pupils (two black circles)
    let pupilRadius = gridSize * 0.1;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.fill();

let mouthWidth = gridSize * 0.8;
    let mouthHeight = gridSize * 0.15;
    ctx.fillStyle = 'black';
    ctx.fillRect(x, y, mouthWidth, mouthHeight);


    ctx.fillStyle = 'black';
    
ctx.fillRect(x - mouthWidth / 2, y + gridSize * 0.8, mouthWidth, mouthHeight);
    
    // Draw the robe (a black rectangle) covering the lower part of the body
    ctx.fillStyle = 'black';
    ctx.fillRect(x - gridSize * 0.7, y, gridSize * 1.4, gridSize);

ctx.strokeStyle = 'white'
    ctx.lineWidth = gridSize * 0.1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y + gridSize);
    ctx.stroke();
        
    // Draw the arms (small black rectangles) connected to the body
    let armWidth = gridSize * 0.2;
    let armHeight = gridSize * 0.6;
    ctx.fillRect(x - gridSize * 0.9, y - gridSize * 0.2, armWidth, armHeight);
    ctx.fillRect(x + gridSize * 0.7, y - gridSize * 0.2, armWidth, armHeight);

    // Draw the feet (black rectangles) touching the body and robe
    let footWidth = gridSize * 0.4;
    let footHeight = gridSize * 0.4;
    ctx.fillRect(x - gridSize * 0.5, y + gridSize * 0.8, footWidth, footHeight);
    ctx.fillRect(x + gridSize * 0.1, y + gridSize * 0.8, footWidth, footHeight);

    // Bounding box calculation
    let boundingBox = {
        xMin: x - gridSize * 0.9,
        yMin: y - gridSize * 1.4,
        xMax: x + gridSize * 0.9,
        yMax: y + gridSize * 1.2
    };

    


    return boundingBox;
}

// Collision detection function
function isCollidingWithFireLord(fireLordBoundingBox, pointX, pointY) {
    return pointX >= fireLordBoundingBox.xMin && pointX <= fireLordBoundingBox.xMax &&
           pointY >= fireLordBoundingBox.yMin && pointY <= fireLordBoundingBox.yMax;
}

        let lightningangle = 0
        let lightningmagic = 0
        let lightninglordInMotion = false;
let lightningLordBoundingBox = drawLightningLord(5, 5);
function manageLightningLord(){
if (lightninglord.length !== 0){
lightningArea(lightninglord[0].x,lightninglord[0].y,2,1)

    if (lightninglordInMotion === false){
    const targetX = snake[0].x * gridSize;
    const targetY = snake[0].y * gridSize;
     lightningangle = Math.atan2(targetY - lightninglord[0].y * gridSize, targetX - lightninglord[0].x * gridSize);
    }
    let velocityX = Math.cos(lightningangle);
    let velocityY = Math.sin(lightningangle);

    if (lightninglord.length > 1) {
        lightninglord.length = 1;
    }
if (lightninglordInMotion === false){
    const magic = ['launch','bolt'];
    const randomIndex = Math.floor(Math.random() * magic.length);
    lightningmagic = magic[randomIndex];
}
    if (lightningmagic === 'launch') {
        lightninglord[0].x += velocityX;
        lightninglord[0].y += velocityY;
lightninglordInMotion = true;
        lightningLordBoundingBox = drawLightningLord(lightninglord[0].x,lightninglord[0].y);

        // Check if the FireLord's bounding box touches any edge of the canvas
        if (lightningLordBoundingBox.xMin < 0 || lightningLordBoundingBox.yMin < 0 ||
            lightningLordBoundingBox.xMax > canvas.width || lightningLordBoundingBox.yMax > canvas.height) {
            // Stop the FireLord
            lightninglordInMotion = false;
        }
}else if (lightningmagic === 'bolt') {
shootWaveOfProjectiles(lightninglord[0].x * gridSize, lightninglord[0].y * gridSize, 1, 1, 0.5,'blue', obstacles, dynamicObstacles, gridSize, 'down', 20, 70, true, 3, false, 20, 1, true,lightninglord)
    }
}
}
let earthVelocityX;
let earthVelocityY;
let earthangle = 0;
let earthmagic = '';
let earthlordInMotion = false;
let earthLordBoundingBox = drawEarthLord(5, 5);

function manageEarthLord() {
    if (earthlord.length === 0) return;
earthArea(earthlord[0].x,earthlord[0].y,2,3)

    const targetX = snake[0].x * gridSize;
    const targetY = snake[0].y * gridSize;
    earthangle = Math.atan2(targetY - earthlord[0].y * gridSize, targetX - earthlord[0].x * gridSize);

    if (!earthlordInMotion) {
        // Increase velocity for noticeable movement
        const stepSize = 0.3; // Adjust step size for smoother movement
        earthVelocityX = Math.cos(earthangle) * stepSize;
        earthVelocityY = Math.sin(earthangle) * stepSize;
    }

    if (earthlord.length > 1) {
        earthlord.length = 1; // Ensure only one earthlord
    }

    // Assign magic action
    if (earthlordInMotion === false){
    const magic = ['launch', 'bolt'];
    const randomIndex = Math.floor(Math.random() * magic.length);
    earthmagic = magic[randomIndex];
}

    if (earthmagic === 'launch') {
        earthlord[0].x += earthVelocityX;
        earthlord[0].y += earthVelocityY;
        earthlordInMotion = true;
        earthLordBoundingBox = drawEarthLord(earthlord[0].x, earthlord[0].y);

        // Check if the Earth Lord's bounding box touches any edge of the canvas
        if (earthLordBoundingBox.xMin < 0 || earthLordBoundingBox.yMin < 0 ||
            earthLordBoundingBox.xMax > canvas.width || earthLordBoundingBox.yMax > canvas.height) {
            // Stop the Earth Lord
            earthlordInMotion = false;
        }
    } else if (earthmagic === 'bolt') {
shootWaveOfProjectiles(earthlord[0].x * gridSize, earthlord[0].y * gridSize, 1, 1, 0.5, 'brown', obstacles, dynamicObstacles, gridSize, 'down', 20, 70, true, 3, false, 20, 1, true,earthlord);
    }

    // Continue moving if in motion
    if (earthlordInMotion) {
        earthlord[0].x += earthVelocityX;
        earthlord[0].y += earthVelocityY;
        earthLordBoundingBox = drawEarthLord(earthlord[0].x, earthlord[0].y);

        // Check if the Earth Lord's bounding box touches any edge of the canvas
        if (earthLordBoundingBox.xMin < 0 || earthLordBoundingBox.yMin < 0 ||
            earthLordBoundingBox.xMax > canvas.width || earthLordBoundingBox.yMax > canvas.height) {
            // Stop the Earth Lord
            earthlordInMotion = false;
        }
    }
}


let  icemahic = 0;
let icelordInMotion = false;
let iceLordBoundingBox = drawIceLord(5,5)
let iceangle
let IcevelocityX
let IcevelocityY
        
function manageIceLord() {
    if (icelord.length === 0) return;

    // Perform actions if icelord is present
    iceArea(icelord[0].x, icelord[0].y, 2, 2);

    const targetX = snake[0].x * gridSize;
    const targetY = snake[0].y * gridSize;
     iceangle = Math.atan2(targetY - icelord[0].y * gridSize, targetX - icelord[0].x * gridSize);
if (!icelordInMotion){
    // Increase velocity for noticeable movement
    const stepSize = 0.3; // Adjust step size for smoother movement
    IcevelocityX = Math.cos(iceangle) * stepSize;
    IcevelocityY = Math.sin(iceangle) * stepSize;
}
    if (icelord.length > 1) {
        icelord.length = 1; // Ensure only one icelord
    }

    // Assign magic action
        if (icelordInMotion === false){
    const magic = ['launch', 'bolt'];
    const randomIndex = Math.floor(Math.random() * magic.length);
    icemahic = magic[randomIndex];
}

    if (icemahic === 'launch') {
        icelord[0].x += IcevelocityX;
        icelord[0].y += IcevelocityY;
        icelordInMotion = true;
        iceLordBoundingBox = drawIceLord(icelord[0].x, icelord[0].y);

        // Check if the IceLord's bounding box touches any edge of the canvas
        if (iceLordBoundingBox.xMin < 0 || iceLordBoundingBox.yMin < 0 ||
            iceLordBoundingBox.xMax > canvas.width || iceLordBoundingBox.yMax > canvas.height) {
            // Stop the IceLord
            icelordInMotion = false;
        }
    }else if (icemahic === 'bolt') {
shootWaveOfProjectiles(icelord[0].x * gridSize, icelord[0].y * gridSize, 1, 1, 0.5, 'blue', obstacles, dynamicObstacles, gridSize, 'down', 20, 70, true, 3, false, 20, 1, true,icelord)
    }

    // Continue moving if in motion
    if (icelordInMotion) {
        icelord[0].x += IcevelocityX;
        icelord[0].y += IcevelocityY;
        iceLordBoundingBox = drawIceLord(icelord[0].x, icelord[0].y);

        // Check if the IceLord's bounding box touches any edge of the canvas
        if (iceLordBoundingBox.xMin < 0 || iceLordBoundingBox.yMin < 0 ||
            iceLordBoundingBox.xMax > canvas.width || iceLordBoundingBox.yMax > canvas.height) {
            // Stop the IceLord
            icelordInMotion = false;
        }
    }
}

        
        let fireangle = 0
        let firelordmagic = 0
        let firelordInMotion = false;
let fireLordBoundingBox = drawFireLord(5, 5);
function manageFireLord(){
if (firelord.length !== 0){
addLavaArea(firelord[0].x,firelord[0].y,2,2)

    if (firelordInMotion === false){
    const targetX = snake[0].x * gridSize;
    const targetY = snake[0].y * gridSize;
     fireangle = Math.atan2(targetY - firelord[0].y * gridSize, targetX - firelord[0].x * gridSize);
    }
    let velocityX = Math.cos(fireangle);
    let velocityY = Math.sin(fireangle);

    if (firelord.length > 1) {
        firelord.length = 1;
    }
if (firelordInMotion === false){
    const magic = ['launch','bolt'];
    const randomIndex = Math.floor(Math.random() * magic.length);
    firelordmagic = magic[randomIndex];
}
    if (firelordmagic === 'launch') {
        firelord[0].x += velocityX;
        firelord[0].y += velocityY;
firelordInMotion = true;
        fireLordBoundingBox = drawFireLord(firelord[0].x, firelord[0].y);

        // Check if the FireLord's bounding box touches any edge of the canvas
        if (fireLordBoundingBox.xMin < 0 || fireLordBoundingBox.yMin < 0 ||
            fireLordBoundingBox.xMax > canvas.width || fireLordBoundingBox.yMax > canvas.height) {
            // Stop the FireLord
            firelordInMotion = false;
        }
}else if (firelordmagic === 'bolt') {
shootWaveOfProjectiles(firelord[0].x * gridSize, firelord[0].y * gridSize, 1, 1, 0.5, 'orange', obstacles, dynamicObstacles, gridSize, 'down', 20, 70, true, 3, false, 20, 1, true,firelord)
    }
}
}

function drawGhostLord(x, y) {
    // Scale the coordinates by gridSize
    x = x * gridSize;
    y = y * gridSize;

    // Draw the body (a red pentagon)
    drawFlatPolygon(x, y, gridSize, 5, ghostcolor);

    // Draw the head (an orange triangle) connected to the body
    drawFlatPolygon(x, y - gridSize * 0.8, gridSize, 3, 'lightgreen');

    // Draw the crown (a yellow pentagon) on the head
    
    // Draw the eyes (two white circles) on the head
    let eyeRadius = gridSize * 0.2;
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, eyeRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw the pupils (two black circles)
    let pupilRadius = gridSize * 0.1;
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(x - gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.arc(x + gridSize * 0.2, y - gridSize, pupilRadius, 0, Math.PI * 2);
    ctx.fill();

    let mouthWidth = gridSize * 0.8;
    let mouthHeight = gridSize * 0.15;
    ctx.fillStyle = 'black';
    ctx.fillRect(x, y, mouthWidth, mouthHeight);

    ctx.fillStyle = 'black';
    ctx.fillRect(x - mouthWidth / 2, y + gridSize * 0.8, mouthWidth, mouthHeight);

    // Draw the robe (a black rectangle) covering the lower part of the body
    ctx.fillStyle = 'black';
    ctx.fillRect(x - gridSize * 0.7, y, gridSize * 1.4, gridSize);

    ctx.strokeStyle = 'lightgray';
    ctx.lineWidth = gridSize * 0.1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y + gridSize);
    ctx.stroke();
        
    // Draw the arms (small black rectangles) connected to the body
    let armWidth = gridSize * 0.2;
    let armHeight = gridSize * 0.6;
    ctx.fillRect(x - gridSize * 0.9, y - gridSize * 0.2, armWidth, armHeight);
    ctx.fillRect(x + gridSize * 0.7, y - gridSize * 0.2, armWidth, armHeight);

    // Draw the feet (black rectangles) touching the body and robe
    let footWidth = gridSize * 0.4;
    let footHeight = gridSize * 0.4;
    ctx.fillRect(x - gridSize * 0.5, y + gridSize * 0.8, footWidth, footHeight);
    ctx.fillRect(x + gridSize * 0.1, y + gridSize * 0.8, footWidth, footHeight);

    // Bounding box calculation
    let boundingBox = {
        xMin: x - gridSize * 0.9,
        yMin: y - gridSize * 1.4,
        xMax: x + gridSize * 0.9,
        yMax: y + gridSize * 1.2
    };

    return boundingBox;
}

// Collision detection function
function isCollidingWithGhostLord(ghostLordBoundingBox, pointX, pointY) {
    return pointX >= ghostLordBoundingBox.xMin && pointX <= ghostLordBoundingBox.xMax &&
           pointY >= ghostLordBoundingBox.yMin && pointY <= ghostLordBoundingBox.yMax;
}

let ghostAngle = 0;
let ghostMagic = 0;
let ghostLordInMotion = false;
let ghostLordBoundingBox = drawGhostLord(5, 5);
let ghostcanteleport = true


function manageGhostLord() {
    if (ghostLord.length !== 0) {
        ghostArea(ghostLord[0].x, ghostLord[0].y, 2, 1);


        if (ghostLordInMotion === false) {
            const targetX = snake[0].x * gridSize;
            const targetY = snake[0].y * gridSize;
            ghostAngle = Math.atan2(targetY - ghostLord[0].y * gridSize, targetX - ghostLord[0].x * gridSize);
        }

        let velocityX = Math.cos(ghostAngle);
        let velocityY = Math.sin(ghostAngle);

        if (ghostLord.length > 1) {
            ghostLord.length = 1;
        }

        
        if (ghostLordInMotion === false) {
            const magic = ['launch', 'bolt', 'port'];
            const randomIndex = Math.floor(Math.random() * magic.length);
            ghostMagic = magic[randomIndex];
        }

        if (ghostMagic === 'launch') {
            ghostLord[0].x += velocityX;
            ghostLord[0].y += velocityY;
            ghostLordInMotion = true;
            ghostLordBoundingBox = drawGhostLord(ghostLord[0].x, ghostLord[0].y);

            if (ghostLordBoundingBox.xMin < 0 || ghostLordBoundingBox.yMin < 0 ||
                ghostLordBoundingBox.xMax > canvas.width || ghostLordBoundingBox.yMax > canvas.height) {
                ghostLordInMotion = false;
            }
        } else if (ghostMagic === 'bolt') {
            shootWaveOfProjectiles(ghostLord[0].x * gridSize, ghostLord[0].y * gridSize, 1, 1, 0.5, 'blue', obstacles, dynamicObstacles, gridSize, 'down', 20, 70, true, 3, false, 20, 1, true, ghostLord);
        } else if (ghostMagic === 'port' && ghostcanteleport === true) {
            const randomX = Math.floor(Math.random() * (canvas.width / gridSize));
            const randomY = Math.floor(Math.random() * (canvas.height / gridSize));
            ghostLord[0].x = randomX;
            ghostLord[0].y = randomY;
            
        } 
    }
}

        
function getDirectionToSnakeHead(x, y, snake) {
    // Get the head of the snake
    const head = snake[0];
  
    // Calculate the differences in x and y coordinates
    const dx = head.x - x;
    const dy = head.y - y;

    // Calculate the magnitude of the vector
    const magnitude = Math.sqrt(dx * dx + dy * dy);

    // Normalize the direction vector (convert to unit vector)
    const direction = {
        x: dx / magnitude,
        y: dy / magnitude
    };

    return direction;
}
let iskamekdead = false;
let onlyoneportal = false
function kamekDeath() {
    isPaused = true;

    if (!onlyoneportal) {
        const randomX = Math.floor(Math.random() * (canvas.width / gridSize));
        const randomY = Math.floor(Math.random() * (canvas.height / gridSize));
        
        let gridOffset = ((2 * gridSize) + (gridSize / 2)) / 2;

        createPortalAnimation(randomX * gridSize, randomY * gridSize, 50, 2000);
    

        turrets.forEach((turret) => {
            createPortalAnimation(turret.x * gridSize, turret.y * gridSize, 30, 2000);
        });

        goombas.forEach((goomba) => {
            createPortalAnimation(goomba.x * gridSize, (goomba.y * gridSize) + (gridSize / 2), 75, 2000);
        });

        createExplosion(ctx, kamek[0].x * gridSize, (kamek[0].y * gridSize) + gridOffset, 'green', obstacles, dynamicObstacles, gridSize, 90);
        createPortalAnimation(kamek[0].x * gridSize, (kamek[0].y * gridSize) + gridOffset, 100, 2000);
onlyoneportal = true
    

        setTimeout(() => {
            kamek = [];
            turrets = [];
            goombas = [];
            timezone = []
            iskamekdead = true;
            startX = randomX * gridSize
            startY = randomY * gridSize
        }, 1100);

        setTimeout(() => {
            isPaused = false;
            kamekappears = false;
            iskamekdead = false;
        }, 2000);
    }
}

        function addCoordsToArray(lavax,lavay){
lavacoords.push({x:lavax,y:lavay})
        }
function shootWaveOfProjectiles(pX, pY, numberOfProjectiles, waveSpreadAngle, projectileSpeed, projectileColor, obstacles, dynamicObstacles, gridSize, direction, projectileSize, explode, circle, sides, increase, updatespeed, explosionstrength, enemy,shooter) {
 
    const directionRadians = {
    'right': inverted ? Math.PI : 0,
    'left': inverted ? 0 : Math.PI,
    'up': inverted ? Math.PI / 2 : -Math.PI / 2,
    'down': inverted ? -Math.PI / 2 : Math.PI / 2
};


    const directionRad = directionRadians[direction.toLowerCase()] || 0;
    const halfSpread = waveSpreadAngle / 2;
    const adjustedAngle = directionRad - (halfSpread * (Math.PI / 180));
    const angleIncrement = (waveSpreadAngle / numberOfProjectiles) * (Math.PI / 180);

    for (let i = 0; i < numberOfProjectiles; i++) {
        let angle;

        if (!enemy) {
            angle = angleIncrement * i + adjustedAngle;
        } else {
            // Initial angle towards the target
            angle = Math.atan2(snake[0].y * gridSize - pY, snake[0].x * gridSize - pX);
        }

        const velocityX = Math.cos(angle) * projectileSpeed;
        const velocityY = Math.sin(angle) * projectileSpeed;

        const projectile = {
            x: pX,
            y: pY,
            angle: angle,
            angle2:angle,
            velocityX: velocityX,
            velocityY: velocityY,
            velocityX2: velocityX,
            velocityY2: velocityY,
            color: projectileColor,
            sides: sides,
            size: projectileSize,
            reflect: false,
            count: 0,
            circle: circle,
            speed:projectileSpeed,
            reflected:true,
            homing: enemy,
            shooter:shooter
        };

        projectiles.push(projectile);
    }

    const updateInterval = setInterval(() => {
        if (!isPaused) {
            projectiles.forEach((projectile, index) => {
                ctx.clearRect(projectile.x - 6, projectile.y - 6, 12, 12);

                if (increase === false || projectile.count <= 5) {
                    if (projectile.homing && flaming === false && projectile.shooter === kamek) {
                        // Adjust velocity to home in on the target
                        const targetX = snake[0].x * gridSize;
                        const targetY = snake[0].y * gridSize;
                        angle = Math.atan2(targetY - projectile.y, targetX - projectile.x);
                        projectile.velocityX = Math.cos(angle) * projectile.speed;
                        projectile.velocityY = Math.sin(angle) * projectile.speed;
                    }
                
                    if (projectile.reflected !== projectile.reflect) {

    if (projectile.reflect) {
        projectile.velocityX = -projectile.velocityX;
        projectile.velocityY = -projectile.velocityY;
        projectile.reflected = projectile.reflect;
    } else {
        // Optionally, store the original velocity if you want to reset to those values
        projectile.velocityX = projectile.velocityX2;
        projectile.velocityY = projectile.velocityY2;
        projectile.reflected = projectile.reflect;
    }
                    }
                    projectile.count += 1
                }

                if (increase && !projectile.homing) {
                    projectile.size += 10;
                    explode = projectile.size * explosionstrength;
                    projectile.x += projectile.velocityX;
                    projectile.y += projectile.velocityY;
                } else {
                    projectile.size = projectileSize;
                    projectile.x += projectile.velocityX;
                        projectile.y += projectile.velocityY;
                }
             
                if (projectile.circle) {
                    ctx.beginPath();
                    ctx.fillStyle = projectile.color;
                    ctx.arc(projectile.x, projectile.y, projectile.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    drawPolygon(projectile.x, projectile.y, projectile.size, projectile.sides, projectile.color);
                }

                if (!projectile.homing){
                timezone.forEach((mirror) => {
                    if (projectile.x >= mirror.x * gridSize && projectile.x <= (mirror.x + 1) * gridSize &&
                        projectile.y >= mirror.y * gridSize && projectile.y <= (mirror.y + 1) * gridSize) {
                        projectile.homing = true;
                        projectile.color = 'purple'
                        projectile.speed = 0.5
                    }
                });

let reflecttime = 0; // Move this line outside of the loop
let colldown = 1000


firelord.forEach((firelord,findex) => {
let firelordhit = isCollidingWithFireLord(fireLordBoundingBox, projectile.x, projectile.y)
if (firelordhit === true){
    firelord.splice(findex,1)
createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
}
})

earthlord.forEach((firelord,findex) => {
let earthlordhit = isCollidingWithFireLord(earthLordBoundingBox, projectile.x, projectile.y)
if (earthlordhit === true){
    earthlord.splice(findex,1)
createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
}
})

ghostLord.forEach((firelord,findex) => {
let ghostlordhit = isCollidingWithFireLord(ghostLordBoundingBox, projectile.x, projectile.y)
if (ghostlordhit === true){
    ghostLord.splice(findex,1)
createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
    isghostdead = true
}
})

chaosLord.forEach((firelord,findex) => {
let chaoslordhit = isCollidingWithFireLord(chaosLordBoundingBox, projectile.x, projectile.y)
if (chaoslordhit === true){
    chaosLord.splice(findex,1)
createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
    chaosdefeated = true
}
})
                    


lightninglord.forEach((firelord,findex) => {
let lightninglordhit = isCollidingWithFireLord(lightningLordBoundingBox, projectile.x, projectile.y)
if (lightninglordhit === true){
    lightninglord.splice(findex,1)
createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
}
})

icelord.forEach((icelord,findex) => {
let icrlordhit = isCollidingWithFireLord(iceLordBoundingBox, projectile.x, projectile.y)
if (icrlordhit === true){
    icelord.splice(findex,1)
createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
}
})
mirrors.forEach((mirror) => {
    if (projectile.x >= mirror.x * gridSize && projectile.x <= (mirror.x + 1) * gridSize &&
        projectile.y >= mirror.y * gridSize && projectile.y <= (mirror.y + 1) * gridSize) {

        const currentTime = new Date().getTime();

        // Check if the cooldown period has elapsed
        if (currentTime - reflecttime < colldown) {
            console.log("Beware of the flying spaghetti monster lurking in the code spaghetti jungle!");
        } else {
            projectile.reflect = !projectile.reflect;
            reflecttime = currentTime; // Update reflecttime to the current time
        }
    }
});
           
                obstacles.forEach((obstacle, obstacleIndex) => {
                    if (projectile.x >= obstacle.x * gridSize && projectile.x <= (obstacle.x + 1) * gridSize &&
                        projectile.y >= obstacle.y * gridSize && projectile.y <= (obstacle.y + 1) * gridSize) {
                        obstacles.splice(obstacleIndex, 1);
                        
                        createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
                    }
                });

        reflector.forEach((obstacle, obstacleIndex) => {
                    if (projectile.x >= obstacle.x * gridSize && projectile.x <= (obstacle.x + 1) * gridSize &&
                        projectile.y >= obstacle.y * gridSize && projectile.y <= (obstacle.y + 1) * gridSize && projectile.reflectored === false) {
                        projectile.reflect = !projectile.reflect
                    }
                });



                dynamicObstacles.forEach((dynamicObstacle, dynamicObstacleIndex) => {
                    if (projectile.x >= dynamicObstacle.x * gridSize && projectile.x <= (dynamicObstacle.x + 2) * gridSize &&
                        projectile.y >= dynamicObstacle.y * gridSize && projectile.y <= (dynamicObstacle.y + 2) * gridSize) {
                        dynamicObstacles.splice(dynamicObstacleIndex, 1);
                        if (projectile.shooter === earthlord){
                    earthArea(projectile.x,projectile.y, 3,3)
                        }
                        createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
                    }
                });

                thwomps.forEach((thwomp, thwompindex) => {
                    if (projectile.x >= thwomp.x * gridSize && projectile.x <= (thwomp.x + 2) * gridSize &&
                        projectile.y >= thwomp.y * gridSize && projectile.y <= (thwomp.y + 2) * gridSize) {
                        thwomps.splice(thwompindex, 1);
                        if (projectile.shooter === earthlord){
                    earthArea(projectile.x,projectile.y, 3,3)
                        }
                        createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
                    }
                });

                esnake.forEach((esnake) => {
                    if (projectile.x >= esnake.x * gridSize && projectile.x <= (esnake.x + 1) * gridSize &&
                        projectile.y >= esnake.y * gridSize && projectile.y <= (esnake.y + 1) * gridSize) {
                    if (projectile.shooter === earthlord){
                    earthArea(projectile.x,projectile.y, 3,3)
                        }
                        createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
                        Dieenemy();
                    }
                });

        kamek.forEach((esnake) => {
                    if (projectile.x >= esnake.x * gridSize && projectile.x <= (esnake.x + 1) * gridSize &&
                        projectile.y >= esnake.y * gridSize && projectile.y <= (esnake.y + 1) * gridSize) {
                        if (projectile.shooter === earthlord){
                    earthArea(projectile.x,projectile.y, 3,3)
                        }
                        createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                        projectiles.splice(index, 1);
                        kamekDeath()
      const distance = Math.abs(kamke[0].x - projectile.x) + Math.abs(kamek[0].y - projectile.y);
      if (distance <= wellStrength) {
          projectile.homing = true
      }
                    }
                });
                setTimeout(() => {
                    snake.forEach((snakePart) => {
                        if (projectile.x >= snakePart.x * gridSize && projectile.x <= (snakePart.x + 1) * gridSize &&
                            projectile.y >= snakePart.y * gridSize && projectile.y <= (snakePart.y + 1) * gridSize) {
                            createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                            projectiles.splice(index, 1);
                        }
                    });
                }, snakeprojectilecollisiontime);

                if (projectile.x < 0 || projectile.x > canvas.width || projectile.y < 0 || projectile.y > canvas.height) {
if (projectile.shooter === earthlord){
                    earthArea(projectile.x,projectile.y, 3,3)
                        }
                    createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                    projectiles.splice(index, 1);
                }
                } else if (projectile.homing){
                snake.forEach((snakePart) => {
                        if ((projectile.x >= snakePart.x * gridSize && projectile.x <= (snakePart.x + 1) * gridSize &&
                            projectile.y >= snakePart.y * gridSize && projectile.y <= (snakePart.y + 1) * gridSize) && !isInvincible) {
                            if (projectile.shooter === earthlord){
                    earthArea(projectile.x/gridSize,projectile.y/gridSize, 3,3)
                        }
if (projectile.shooter === icelord){
                    iceArea(projectile.x/gridSize,projectile.y/gridSize, 4,3)
                        }
    if (projectile.shooter === firelord){
                    addLavaArea(projectile.x/gridSize,projectile.y/gridSize, 3,2)
    }
    if (projectile.shooter === lightninglord){
                    lightningArea(projectile.x/gridSize,projectile.y/gridSize, 3,1)
                        }
                            createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                            projectiles.splice(index, 1);
                            const numSegmentsToRemove = Math.ceil(snake.length * 0.01);
        if (snake.length > numSegmentsToRemove) {
            snake.splice(0, numSegmentsToRemove);
            HaHaNoCollision(10)
            
        } else {
            restartGame(); // End the game if segments (lives) run out
            return;
        }
                            
                        }
                    });
if (projectile.x < 0 || projectile.x > canvas.width || projectile.y < 0 || projectile.y > canvas.height) {
if (projectile.shooter === earthlord){
                    earthArea(projectile.x/gridSize,projectile.y/gridSize, 3,3)
                        }
if (projectile.shooter === icelord){
                    iceArea(projectile.x/gridSize,projectile.y/gridSize, 4,3)
                        }
    if (projectile.shooter === firelord){
                    addLavaArea(projectile.x/gridSize,projectile.y/gridSize, 3,2)
    }
    if (projectile.shooter === lightninglord){
                    lightningArea(projectile.x/gridSize,projectile.y/gridSize, 3,1)
                        }
                    createExplosion(ctx, projectile.x, projectile.y, projectile.color, obstacles, dynamicObstacles, gridSize, explode);
                    projectiles.splice(index, 1);
                }

                }
            });

            if (projectiles.length === 0) {
                clearInterval(updateInterval);
            }
        }
    }, updatespeed);
}
        

function createExplosion(ctx, x, y, color, obstacles, dynamicObstacles, gridSize, explode) {
    ctx.beginPath();
    ctx.arc(x, y, explode, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.5;
    ctx.fill();
    ctx.globalAlpha = 1
    obstacles.forEach((obstacle, obstacleIndex) => {
        const obstacleCenterX = (obstacle.x + 0.5) * gridSize;
        const obstacleCenterY = (obstacle.y + 0.5) * gridSize;
        const distance = Math.sqrt((obstacleCenterX - x) ** 2 + (obstacleCenterY - y) ** 2);

        if (distance <= explode) {
            obstacles.splice(obstacleIndex, 1);
        }
    });


    timezone.forEach((obstacle, index) => {
                if (x >= obstacle.x * gridSize && x <= (obstacle.x + 1) * gridSize &&
                    y >= obstacle.y * gridSize && y <= (obstacle.y + 1) * gridSize) {
                    // Remove the obstacle from the array
                    timezone.splice(index, 1);
                }
            });
    
    dynamicObstacles.forEach((dynamicObstacle, dynamicObstacleIndex) => {
        const dynamicObstacleCenterX = (dynamicObstacle.x + 1) * gridSize;
        const dynamicObstacleCenterY = (dynamicObstacle.y + 1) * gridSize;
        const distance = Math.sqrt((dynamicObstacleCenterX - x) ** 2 + (dynamicObstacleCenterY - y) ** 2);

        if (distance <= explode) {
            dynamicObstacles.splice(dynamicObstacleIndex, 1);
        }
    });

    thwomps.forEach((thwomp, dynamicObstacleIndex) => {
        const thwompx = (thwomp.x + 1) * gridSize;
        const thwompy = (thwomp.y + 1) * gridSize;
        const distance = Math.sqrt((thwompx - x) ** 2 + (thwompy - y) ** 2);

        if (distance <= explode) {
            thwomps.splice(dynamicObstacleIndex, 1);
        }
    });
}

function enemyshootmagic() {
    if (kamek.length !== 0) {
        kamek.forEach((kamek, index) => {
            shootWaveOfProjectiles(kamek.x * gridSize, kamek.y * gridSize, 1, 1, 0.5, 'purple', obstacles, dynamicObstacles, gridSize, 'down', 20, 70, true, 3, false, 20, 1, true,kamek);
        });
    }
}

function shockwaveAnimation(x, y) {
    // Get the canvas element
    // Set up animation parameters
    const radiusMax = Math.max(canvas.width, canvas.height);
    let radius = 0;
    const maxOpacity = 0.6;
    let opacity = maxOpacity;

    // Animation loop
    function animate() {
        // Decrease opacity
        opacity -= 0.005;

        // Draw the shockwave
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(165, 42, 42, ${opacity})`;
        ctx.fill();

        // Increase radius
        radius += 5;

        // Check if animation is complete
        if (opacity <= 0) {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Reset parameters for next animation
            radius = 0;
            opacity = maxOpacity;
            cancelAnimationFrame(animationId);
            applyEarthquake(obstacles)
            isPaused = false
            return;
        }

        // Request next frame
        animationId = requestAnimationFrame(animate);
    }

    // Start the animation
    let animationId = requestAnimationFrame(animate);
}

function checkIfPaused() {
    if (isPaused && !Object.is(direction, previousDirection))
        direction = previousDirection;
}
setInterval(checkIfPaused, 1);


// Define a function to apply the earthquake (without visual effects)
function applyEarthquake(obstacles) {
    // Iterate through obstacles
    obstacles.forEach(obstacle => {
        // Randomly decide whether to shift or collapse the obstacle
        if (Math.random() <= 0.99) {
            // Shift the obstacle by a random amount
            obstacle.x += Math.floor(Math.random() * 3) - 1; // Shift left or right by 1 grid
            obstacle.y += Math.floor(Math.random() * 3) - 1; // Shift up or down by 1 grid
             
        } else {
            // Collapse the obstacle by removing it from the array
            let index = obstacles.indexOf(obstacle);
            obstacles.splice(index, 1);
            let index2 = dynamicObstacles.indexOf(dynamicObstacle);
            dynamicObstacles.splice(index2, 1);
        }
    });
}


const laser = {
    isShooting: false,
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    width: gridSize// Width of the laser (in pixels)
};

// Handle tap events for shooting the laser
let tapStartX = 0;
let tapStartY = 0;
let tapEndX = 0;
let tapEndY = 0;

function handleTapStart(event) {
    if (event.type === 'touchstart') {
        startX = event.touches[0].clientX;
        startY = event.touches[0].clientY;
        if (controltype === 'set') {
controltype = 'mobile'
        }
    } else if (event.type === 'mousedown') {
        startX = event.clientX;
        startY = event.clientY;
        if (controltype === 'set') {
controltype = 'arrow'
        }
    }
}

function handleTapEnd(event) {
    if (event.type === 'touchend') {
        endX = event.changedTouches[0].clientX;
        endY = event.changedTouches[0].clientY;
    } else if (event.type === 'mouseup') {
        endX = event.clientX;
        endY = event.clientY;
    }

    // Calculate the distance between start and end points
    const deltaX = Math.abs(endX - startX);
    const deltaY = Math.abs(endY - startY);

    // If the distance is small enough, treat it as a tap/click
    if (deltaX < 10 && deltaY < 10) {
        // Only shoot the laser if it's not already shooting
        if (!laser.isShooting) {
            const canvasRect = canvas.getBoundingClientRect();
            const canvasX = endX - canvasRect.left;
            const canvasY = endY - canvasRect.top;
            shootLaser(canvasX, canvasY);
        }
    }
}
canvas.addEventListener('touchstart', handleTapStart);
canvas.addEventListener('touchend', handleTapEnd);
canvas.addEventListener('mousedown', handleTapStart);
canvas.addEventListener('mouseup', handleTapEnd);

// Drawing function to draw the laser with fade effect
function drawLaser() {
    if (laser.isShooting) {
        // Calculate the alpha value for the fade effect
        const currentTime = Date.now();
        const elapsedTime = currentTime - laserStartTime;
        let alpha = 1 - (elapsedTime / 5000); // Fade out over 5 seconds
        alpha = Math.max(0, alpha); // Ensure alpha is not negative

        // Set the stroke style with alpha
        ctx.beginPath();
        ctx.lineWidth = laser.width;
        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`; // Color of the laser with alpha
        ctx.moveTo(laser.x1, laser.y1);
        ctx.lineTo(laser.x2, laser.y2);
        ctx.stroke();
    }
}

let lastLaserShot = 0; // Timestamp of the last laser shot
let laserCooldown = laserTimer * 1000; // Cooldown period in milliseconds (30 seconds)


        // Function to handle shooting the laser
function shootLaser(targetX, targetY) {
    const currentTime = new Date().getTime();

    // Check if the cooldown period has elapsed
    if (currentTime - lastLaserShot < laserCooldown) {
        return; // Laser is still on cooldown
    } else {
        isShooting = true;
        charging = false;
        // Calculate the angle and distance to the canvas edge
        const snakeHeadX = snake[0].x * gridSize;
        const snakeHeadY = snake[0].y * gridSize;
        const dx = targetX - snakeHeadX;
        const dy = targetY - snakeHeadY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        // Draw the laser with fade effect
        const gradient = ctx.createLinearGradient(snakeHeadX, snakeHeadY, snakeHeadX + Math.cos(angle) * distance, snakeHeadY + Math.sin(angle) * distance);
        gradient.addColorStop(0, 'rgba(255, 0, 0, 1)'); // Start with full opacity
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)'); // Fade out to fully transparent

        // Draw the laser line
        ctx.beginPath();
        ctx.moveTo(snakeHeadX, snakeHeadY);

        // Store the pixels of the laser line
        const laserPixels = [];

        // Check for collision for every pixel along the line
        for (let i = 0; i <= distance; i++) {
            const x = snakeHeadX + Math.cos(angle) * i;
            const y = snakeHeadY + Math.sin(angle) * i;

            // Add the pixel coordinates to the laserPixels array
            laserPixels.push({ x: x, y: y });
if (kamekappears === false) {
            // Check for collision with obstacles for the laser pixel
            obstacles.forEach((obstacle, index) => {
                if (x >= obstacle.x * gridSize && x <= (obstacle.x + 1) * gridSize &&
                    y >= obstacle.y * gridSize && y <= (obstacle.y + 1) * gridSize) {
                    // Remove the obstacle from the array
                    obstacles.splice(index, 1);
                }
            });
}
let isfirelordhit = isCollidingWithFireLord(fireLordBoundingBox, x, y)
if (isfirelordhit === true) {
firelord = []
}

let chaoslordhit = isCollidingWithFireLord(chaosLordBoundingBox, x, y)
if (chaoslordhit === true) {
chaosLord = []
chaosdefeated = true
}

            
let isghostlordhit = isCollidingWithFireLord(ghostLordBoundingBox, x, y)
if (isghostlordhit === true) {
ghostLord = []
    isghostdead = true
}
            
let islightninglordhit = isCollidingWithFireLord(lightningLordBoundingBox, x, y)
if (islightninglordhit === true) {
lightninglord = []
}

  let isicelordhit = isCollidingWithFireLord(iceLordBoundingBox, x, y)
if (isicelordhit === true) {
icelord = []
}          
let isearthlordhit = isCollidingWithFireLord(earthLordBoundingBox, x, y)
if (isearthlordhit === true) {
earthlord = []
}
    
            timezone.forEach((obstacle, index) => {
                if (x >= obstacle.x * gridSize && x <= (obstacle.x + 1) * gridSize &&
                    y >= obstacle.y * gridSize && y <= (obstacle.y + 1) * gridSize && hascollided === false) {
                    // Remove the obstacle from the array
                    sideshield -= 1
                    hascollided = true
                }
            });

            if (kamekappears === false){
            // Check for collision with dynamic obstacles for the laser pixel
            dynamicObstacles.forEach((obstacle, index) => {
                if (x >= obstacle.x * gridSize && x <= (obstacle.x + 2) * gridSize &&
                    y >= obstacle.y * gridSize && y <= (obstacle.y + 2) * gridSize) {
                    // Remove the dynamic obstacle from the array
                    dynamicObstacles.splice(index, 1);
                }
            });
        
thwomps.forEach((obstacle, index) => {
                if (x >= obstacle.x * gridSize && x <= (obstacle.x + 2) * gridSize &&
                    y >= obstacle.y * gridSize && y <= (obstacle.y + 2) * gridSize) {
                    // Remove the dynamic obstacle from the array
                    thwomps.splice(index, 1);
                }
            });
            }
         if(kamek.length > 0){
    for (let i = kamek.length - 1; i >= 0; i--) {
    let kamekElement = kamek[i];
    let collisionResult = isCollidingWithKamek(
        kamekElement.x * gridSize,
        kamekElement.y * gridSize,
        gridSize,
        x,
        y
    );

    if (collisionResult === true && sideshield <= 2) {
        kamekDeath()
        }
    }}
        }
        
        // Draw the laser line with fade effect
        ctx.strokeStyle = gradient;
        ctx.lineWidth = gridSize; // Increase the thickness of the laser
        laserPixels.forEach((pixel, index) => {
            if (index === 0) {
                ctx.moveTo(pixel.x, pixel.y);
            } else {
                ctx.lineTo(pixel.x, pixel.y);
            }
        });
        ctx.stroke();

if (kamekappears === true && laserTimer < 11.25){
        laserTimer = laserTimer/2
           laserCooldown = laserTimer * 1000 
}else if (kamekappears === false){
    laserTimer = LaserCooldownReset
           laserCooldown = laserTimer * 1000 

}
        // After 5 seconds, reset the shooting state and fade out the laser

        
            isShooting = false;
            charging = true;
        
        hascollided = false
        
        // Update the timestamp of the last laser shot
        lastLaserShot = currentTime;
    }
}
// Function to pause the game
function pauseGame() {
    isPaused = !isPaused; // Toggle the paused state
}



function draw() {
    // Function to clear a specific area
    function clearArea(x, y, width, height) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(x * gridSize, y * gridSize, width * gridSize, height * gridSize);
        ctx.clip();
        ctx.clearRect(x * gridSize, y * gridSize, width * gridSize, height * gridSize);
        ctx.restore();
    }

    // Clear and update the areas that need to be redrawn
    function clearAndDrawObstacles(obstacles, color) {
        ctx.fillStyle = color;
        obstacles.forEach(obstacle => {
            clearArea(obstacle.x, obstacle.y, 1, 1);
            ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
        });
    }

    // Clear the entire background
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.clip();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();

    // Draw the earth obstacles
    ctx.fillStyle = earthcolor;
    earth.forEach(obstacle => ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize));

    clearAndDrawObstacles(ectoplasm, ghostcolor)
    ctx.fillStyle = electriccolor;
    electric.forEach(obstacle => ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize));
    
    ctx.fillStyle = icecolor;
    ice.forEach(obstacle => ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize));
    // Draw the earth obstacles
    ctx.fillStyle = lavacolor;
    lava.forEach(obstacle => ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize));
    // Draw Kamek
    if (kamek.length !== 0) {
        kamek.forEach(kamek => {
            clearArea(kamek.x, kamek.y, 1, 1);
            drawKamek(kamek.x, kamek.y);
        });
    }

    // Draw Goombas
    if (goombas.length !== 0) {
        goombas.forEach(goomba => {
            clearArea(goomba.x, goomba.y, 1, 1);
            drawGoomba(goomba.x, goomba.y);
        });
    }

    // Draw invincibility auras
    if (isInvincible) {
        drawInvincibilityAura('orange');
    }
    const currentTime = new Date().getTime();
    if (charging && !(currentTime - lastLaserShot < laserCooldown)) {
        drawInvincibilityAura('red');
        setTimeout(() => { charging = false; }, 1000);
    }

    if (GravityApplied && gravitycount > 0) {
        drawInvincibilityAura('magenta');
    }

    if (isFoodOrange) {
        drawInvincibilityAura('green');
        setTimeout(() => { isFoodOrange = false; }, 400);
    }

    if (freeze) {
        drawInvincibilityAura('blue');
        setTimeout(() => { freeze = false; }, freezetimer * 1000);
    }

    // Draw the snake
    snake.forEach(segment => {
        clearArea(segment.x, segment.y, 1, 1);
        ctx.fillStyle = segment.color;
        ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
    });

    // Draw enemy snake
    if (esnake.length !== 0) {
        ctx.fillStyle = getenemycolor(esnake[0].type);
        esnake.forEach(esnake => {
            clearArea(esnake.x, esnake.y, 1, 1);
            ctx.fillRect(esnake.x * gridSize, esnake.y * gridSize, gridSize, gridSize);
        });
    }

    // Draw symbiote
    if (symbiote.length !== 0) {
        symbiote.forEach(symbiote => {
            clearArea(symbiote.x, symbiote.y, 1, 1);
            ctx.fillStyle = getVenomColor(symbiote.type);
            ctx.fillRect(symbiote.x * gridSize, symbiote.y * gridSize, gridSize, gridSize);
        });
    }

    // Draw the snake's head
    const head = snake[0];
    clearArea(head.x, head.y, 1, 1);
    ctx.fillStyle = 'lightgreen';
    ctx.fillRect(head.x * gridSize, head.y * gridSize, gridSize, gridSize);

    // Draw item
    if (item.length !== 0) {
        item.forEach(it => {
            clearArea(it.x, it.y, 1, 1);
            ctx.fillStyle = getitem(it.type);
            ctx.fillRect(it.x * gridSize, it.y * gridSize, gridSize, gridSize);
        });
    }

    // Draw food
    clearArea(food.x, food.y, 1, 1);
    ctx.fillStyle = getFoodColor(food.type);
    ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);

    // Draw eating animation
    if (isEating) {
        drawEatingAnimation();
    }

    // Draw other obstacles
    clearAndDrawObstacles(obstacles, 'black');
    clearAndDrawObstacles(timezone, 'lightgreen');
    clearAndDrawObstacles(reflector, '#5B8DFF');

    chaosLord.forEach(firelord => {
        clearArea(firelord.x, firelord.y, 1, 1);
        drawChaosLord(firelord.x, firelord.y);
    });
    
    // Draw special entities
    firelord.forEach(firelord => {
        clearArea(firelord.x, firelord.y, 1, 1);
        drawFireLord(firelord.x, firelord.y);
    });
    lightninglord.forEach(firelord => {
        clearArea(firelord.x, firelord.y, 1, 1);
        drawLightningLord(firelord.x, firelord.y);
    });
    earthlord.forEach(firelord => {
        clearArea(firelord.x, firelord.y, 1, 1);
        drawEarthLord(firelord.x, firelord.y);
    });
    icelord.forEach(firelord => {
        clearArea(firelord.x, firelord.y, 1, 1);
        drawIceLord(firelord.x, firelord.y);
    });

ghostLord.forEach(firelord => {
        clearArea(firelord.x, firelord.y, 1, 1);
        drawGhostLord(firelord.x, firelord.y);
    });
    
    // Draw gravity well warning
    if (isGravityWellActive) {
        ctx.fillStyle = scorecolor;
        wellWarning.forEach(obstacle => {
            clearArea(obstacle.x, obstacle.y, 1, 1);
            ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
        });
    }

    // Draw wells with pulsating effect
    ctx.fillStyle = wellcolor;
    wells.forEach(well => {
        const pulse = Math.sin(Date.now() / 200) * 5;
        clearArea(well.x, well.y, 1, 1);
        ctx.fillRect(well.x * gridSize - pulse / 2, well.y * gridSize - pulse / 2, gridSize + pulse, gridSize + pulse);
    });

    // Draw mirrors
    clearAndDrawObstacles(mirrors, 'darkgrey');
    clearAndDrawObstacles(turrets, '#6ec485');

    // Draw thwomps and dynamic obstacles
    thwomps.forEach(obstacle => {
        clearArea(obstacle.x, obstacle.y, 2, 2);
        ctx.fillStyle = 'black';
        ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize * 2, gridSize * 2);
    });

    dynamicObstacles.forEach(obstacle => {
        clearArea(obstacle.x, obstacle.y, 2, 2);
        ctx.fillStyle = 'grey';
        ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize * 2, gridSize * 2);
    });

    // Draw score
    const scoreDisplay = document.getElementById('scoreDisplay');
    scoreDisplay.innerHTML = `Score: ${score}<br>Lives: ${livecount}`;
    drawLaser();
}


function drawInvincibilityAura(colorName) {
    // Mapping of color names to RGBA values
    const colorMap = {
        'red': 'rgba(255, 0, 0, 0.3)',
        'green': 'rgba(0, 255, 0, 0.3)',
        'blue': 'rgba(0, 0, 255, 0.3)',
        'magenta': 'rgba(255, 8, 232, 0.3)',
        // Add more colors as needed
    };
    
    var deviceWidth, landscape = Math.abs(window.orientation) == 90;
    // workaround for strange screen.height on the iPhone (v3.1.3)
    if (window.screen.width == 320) deviceWidth = landscape ? 480 : 320;
    else deviceWidth = window.screen[landscape ? "height" : "width"];
    var zoomFactor = deviceWidth / window.innerWidth;
    var antiZoomFactor = 1 / zoomFactor;
    getZoomFactor();
    snake.forEach((segment, index) => {
        const shadowSize = 8 * antiZoomFactor; // Adjust the size of the shadow
        // Set color based on the input color name
        ctx.fillStyle = colorMap[colorName.toLowerCase()] || 'rgba(255, 135, 0, 0.3)'; // Default to orange if color name not found
        ctx.fillRect(segment.x * gridSize - shadowSize, segment.y * gridSize - shadowSize, gridSize + shadowSize * 2, gridSize + shadowSize * 2);
    });
}


function drawEatingAnimation() {
    getZoomFactor()
    var deviceWidth, landscape = Math.abs(window.orientation) == 90
            // workaround for strange screen.height on the iPhone (v3.1.3)
            if (window.screen.width == 320) deviceWidth = landscape ? 480 : 320
            else deviceWidth = window.screen[landscape ? "height" : "width"]
            var zoomFactor = deviceWidth / window.innerWidth;
            var antiZoomFactor = 1 / zoomFactor;
    const animationColor = 'rgba(0, 0, 255, 0.5)'; // Blue color with transparency
    let segmentSize = gridSize; // Adjust segment size based on anti-zoom factor
    let waveSize = 5; // Adjust the size of the wave based on anti-zoom factor
    let maxFrames = 8; // Number of frames for the eating animation

    let head = snake[0];
    let eatenSegments = snake.slice(1, eatingAnimationFrames + 1);
eatenSegments.forEach((segment, index) => {
    let animationFrame = eatingAnimationFrames - index;
    const segmentX = segment.x * gridSize;
    const segmentY = segment.y * gridSize;

    let originalOffset = waveSize * (maxFrames - animationFrame);
    var scaledOffset = Math.max(0, Math.ceil(originalOffset * antiZoomFactor));

    // Draw the wave-like effect
    ctx.fillStyle = animationColor;
    ctx.fillRect(segmentX, segmentY, segmentSize, segmentSize);
    ctx.fillRect(segmentX - scaledOffset, segmentY, segmentSize, segmentSize);
    ctx.fillRect(segmentX + scaledOffset, segmentY, segmentSize, segmentSize);
    ctx.fillRect(segmentX, segmentY - scaledOffset, segmentSize, segmentSize);
    ctx.fillRect(segmentX, segmentY + scaledOffset, segmentSize, segmentSize);

    // Draw the original segment
    ctx.fillRect(segmentX, segmentY, segmentSize, segmentSize);
});

originalSnakeColor = '#00FF00'; // Reset snake color after eating animation
}

function getVenomColor(symbioteType){
    switch (symbioteType) {
        case 'magnet':
            return 'grey';
        case 'wave':
            return 'orange'
    }
}


function getFoodColor(foodType) {

    switch (foodType) {
        case 'earth':
            return 'brown';
        case 'ice':
            return 'lightblue';
        case 'normal':
            return 'red';
        case 'superfood':
            return 'gold';
        case 'poison':
            return 'purple';
        case 'teleport':
            return 'blue';
        case 'invincibility':
            return 'turquoise';
        case 'fire':
            return 'orange';
        case 'ultrafood':
            return 'darkblue';
        case 'air':
            return 'lightgrey';
        default:
            return 'red';
        case 'morph':
            return neoncolor;
        case 'breath':
            return sunset;
        case 'slow':
            return timeslow;
        case 'fast':
            return timespeed
       }
}

// Function to trigger invincibility
function HaHaNoCollision(duration) {
    isInvincible = true;
    invincibilityDuration = duration; // Set the duration for invincibility
}
      
        function pickrandomeffect(){
            const types = ['teleport']; // Possible directions
    const randomIndex = Math.floor(Math.random() * types.length);
    timezone.type = types[randomIndex];
        }
        function update() {
            if (isPossessed && !GravityApplied){
            possessionmove()
            }
            // If the snake is invincible, decrement the invincibility duration
            if (isInvincible) {
                invincibilityDuration--;
                // If the invincibility duration has expired, reset the invincibility status
                if (invincibilityDuration <= 0) {
                    isInvincible = false;
                }
            }
            if (GravityApplied && !snakecutgravity){
 if (snake.length > 10){
                snake.length = 10
 }
                snakecutgravity = true
            }
            if (!GravityApplied){
snake = snake2.slice();
            snakecutgravity = false
            }
            ManageTurrets()
            if (kamek.length !== 0){
                kamekUpdate()
            }
if (!isPaused && earthlord.length !== 0){
          manageEarthLord()  
}
            if (!isPaused && firelord.length !== 0){
            manageFireLord()
            }

if (!isPaused && icelord.length !== 0){
            manageIceLord()
            }
   if (!isPaused && ghostLord.length !== 0){
            manageGhostLord()
            }         
if (!isPaused && lightninglord.length !== 0){
            manageLightningLord()
}

if (!isPaused && chaosLord.length !== 0){
            manageChaosLord()
}
            
            lavacoords.forEach((coords, index) => {
            addLavaArea(coords.x, coords.y, 4,4)
            lavacoords.splice(index,1)
            })
    for (let index = lava.length - 1; index >= 0; index--) {
        let lavaElement = lava[index];
        if (lavaElement.countdown > 0) {
            lavaElement.countdown -= 0.1;
        }
        if (lavaElement.countdown <= 0) {
            lava.splice(index, 1);
        }
    }

for (let index = earth.length - 1; index >= 0; index--) {
        let earthElement = earth[index];
        if (earthElement.countdown > 0) {
            earthElement.countdown -= 0.1;
        }
        if (earthElement.countdown <= 0) {
            earth.splice(index, 1);
        }
    }
            
for (let index = electric.length - 1; index >= 0; index--) {
        let lightningElement = electric[index];
        if (lightningElement.countdown > 0) {
            lightningElement.countdown -= 0.1;
        }
        if (lightningElement.countdown <= 0) {
            electric.splice(index, 1);
        }
    }

for (let index = ice.length - 1; index >= 0; index--) {
        let iceElement = ice[index];
        if (iceElement.countdown > 0) {
            iceElement.countdown -= 0.1;
        }
        if (iceElement.countdown <= 0) {
            ice.splice(index, 1);
        }
    }
        
            for (let index = ectoplasm.length - 1; index >= 0; index--) {
        let ectoplasmElement = ectoplasm[index];
        if (ectoplasmElement.countdown > 0) {
            ectoplasmElement.countdown -= 0.1;
        }
        if (ectoplasmElement.countdown <= 0) {
            ectoplasm.splice(index, 1);
        }
    }
            // Update Snake position
            const head = { ...snake[0] };
            const head2 = { ...snake2[0] };
// Define a variable to store the previous direction
 isIced = ice.some((ice) => {
    return ice.x === head.x && ice.y === head.y;
});

isEarthed = earth.some((earth) => {
    return earth.x === head.x && earth.y === head.y;
});
            
// Store the current direction as the previous direction
previousDirection = direction;

// Update the direction based on user input or logic
            if (inverted === false){
switch (direction) {
    case 'up':
        head.y = (head.y - 1 + canvas.height / gridSize) % (canvas.height / gridSize);
        head2.y = (head2.y - 1 + canvas.height / gridSize) % (canvas.height / gridSize);
        track = []
        track = [{x:head.x, y:head.y + 1}]
        break;
    case 'down':
        head.y = (head.y + 1) % (canvas.height / gridSize);
        head2.y = (head2.y + 1) % (canvas.height / gridSize);
        
        track = []
        track = [{x:head.x, y:head.y - 1}]
        break;
    case 'left':
        head.x = (head.x - 1 + canvas.width / gridSize) % (canvas.width / gridSize);
            head2.x = (head2.x - 1 + canvas.width / gridSize) % (canvas.width / gridSize);
            
        track = []
        track = [{x:head.x + 1, y:head.y}]
        break;
    case 'right':
        head.x = (head.x + 1) % (canvas.width / gridSize);
      head2.x = (head2.x + 1) % (canvas.width / gridSize);
  
        track = []
        track = [{x:head.x - 1, y:head.y}]
        break;
}
            }else if (inverted === true){
           switch (direction) {
    case 'down':
        head.y = (head.y - 1 + canvas.height / gridSize) % (canvas.height / gridSize);
        head2.y = (head2.y - 1 + canvas.height / gridSize) % (canvas.height / gridSize);
        
        track = []
        track = [{x:head.x, y:head.y + 1}]
        break;
    case 'up':
        head.y = (head.y + 1) % (canvas.height / gridSize);
       head2.y = (head2.y + 1) % (canvas.height / gridSize);
        
                   track = []
        track = [{x:head.x, y:head.y - 1}]
        break;
    case 'right':
        head.x = (head.x - 1 + canvas.width / gridSize) % (canvas.width / gridSize);
        head2.x = (head2.x - 1 + canvas.width / gridSize) % (canvas.width / gridSize);
        
        track = []
        track = [{x:head.x + 1, y:head.y}]
        break;
    case 'left':
        head.x = (head.x + 1) % (canvas.width / gridSize);
    head2.x = (head2.x + 1) % (canvas.width / gridSize);
      
                   track = []
        track = [{x:head.x - 1, y:head.y}]
        break;
}
       }

const checkCollisions = (obstacles, isDynamic) => {
    obstacles.forEach((obstacle, index) => {
        lava.forEach((lava) => {
            if (
                (isDynamic
                    ? lava.x >= obstacle.x && lava.x < obstacle.x + 2 &&
                      lava.y >= obstacle.y && lava.y < obstacle.y + 2
                    : lava.x === obstacle.x && lava.y === obstacle.y)
            ) {
                obstacles.splice(index, 1);
            }
        });
    });
};
goombas.forEach((goomba,index) => {
GoombaCollision = isPointInGoombaBoundingBox(snake[0].x* gridSize, snake[0].y * gridSize,goomba.x, goomba.y)
    if (!isInvincible && (GoombaCollision === true && direction !== 'down')){
const numSegmentsToRemove = Math.ceil(snake.length * lives);
        if (snake.length > numSegmentsToRemove) {
            snake.splice(0, numSegmentsToRemove);
            snake2.splice(0, numSegmentsToRemove);
            lives = (lives * 2);
            livecount = livecount - 1;
            HaHaNoCollision(10)
    } else {
            livecount = livecount - 1;
            restartGame(); // End the game if segments (lives) run out
            return;
        }              
}
})

// Static obstacles
checkCollisions(obstacles, false);
checkCollisions(mirrors, false);
checkCollisions(wells, false);

// Dynamic obstacles
checkCollisions(dynamicObstacles, true);
checkCollisions(thwomps, true);

if(kamek.length === 0 && !physicsActive){
isParalyzed = electric.some((electric) => {
    return electric.x === head.x && electric.y === head.y;
});
}
isPossessed = ectoplasm.some((ectoplasm) => {
    return ectoplasm.x === head.x && ectoplasm.y === head.y;
});
const checkIfInScoreArea = (obstacles, isDynamic) => {
    obstacles.forEach((obstacle, index) => {
        scoreAreaArray.forEach((lava) => {
            if (
                (isDynamic
                    ? lava.x >= obstacle.x && lava.x < obstacle.x + 2 &&
                      lava.y >= obstacle.y && lava.y < obstacle.y + 2
                    : lava.x === obstacle.x && lava.y === obstacle.y)
            ) {
                obstacles.splice(index, 1);
            }
        });
    });
}

    checkIfInScoreArea(obstacles, false);
checkIfInScoreArea(mirrors, false);
checkIfInScoreArea(wells, false);

// Dynamic obstacles
checkIfInScoreArea(dynamicObstacles, true);
            
            // Check if Snake hits obstacles
            if (!isInvincible && (obstacles.some(obstacle => obstacle.x === head.x && obstacle.y === head.y)) ||
                !isInvincible && dynamicObstacles.some(obstacle => (head.x >= obstacle.x && head.x < obstacle.x + 2) &&
                    (head.y >= obstacle.y && head.y < obstacle.y + 2)) || !isInvincible && thwomps.some(obstacle => (head.x >= obstacle.x && head.x < obstacle.x + 2) &&
                    (head.y >= obstacle.y && head.y < obstacle.y + 2)) ||!isInvincible && lava.some(obstacle => obstacle.x === head.x && obstacle.y === head.y)) {          
        const numSegmentsToRemove = Math.ceil(snake.length * lives);
        if (snake.length > numSegmentsToRemove) {
            snake.splice(0, numSegmentsToRemove);
            snake2.splice(0, numSegmentsToRemove);
          
            lives = (lives * 2);
            livecount = livecount - 1;
            HaHaNoCollision(10)
            
        } else {
            livecount = livecount - 1;
            restartGame(); // End the game if segments (lives) run out
            return;
        }              
            }
if (esnake.length !== 0){
if (!isInvincible &&  (esnake.some(esnake => (esnake.x === (snake[1].x) && esnake.y === (snake[1].y)) && esnake.damage === false))){
    if (esnake[0].type === 'base'){
             const numSegmentsToRemove2 = Math.ceil(snake.length * lives);
        if (snake.length > numSegmentsToRemove2) {
            snake.splice(0, numSegmentsToRemove2);
            snake2.splice(0, numSegmentsToRemove2);
            
            lives = (lives * 2);
            livecount = livecount - 1;
            HaHaNoCollision(10)
esnake.forEach(enemySegment => enemySegment.damage = true)
        } else {
            livecount = livecount - 1;
            restartGame(); // End the game if segments (lives) run out
            return;
        }              
}
if (esnake[0].type === 'IRS' && esnake[0].damage === false) {
        let tax = score * taxrate;
        score -= tax;
        score = Math.floor(score);
        esnake.forEach(enemySegment => enemySegment.damage = true);
    }

    if (!isInvincible && esnake.some(segment => segment.x === snake[1].x && segment.y === snake[1].y && segment.damage === false && segment.type === 'IRS')) {
        isTaxed = false;
    }

    if (score <= 0 && isTaxed === true) {
        score = 0;
        esnake = [];
    }

}
}
if (!isInvincible && mirrors.some(obstacle => obstacle.x === head.x && obstacle.y === head.y)) {
    // If the head collides with a mirror and the player is not invincible
    // Reverse the direction of movement
    switch (direction) {
        case 'right':
            if (!mirrors.some(obstacle => obstacle.x === head.x + 1 && obstacle.y === head.y) && !isCollidingWithBody(head.x + 1, head.y)) {
                cancelEffects()
                direction = 'left';
                snake[0].x -= 1;
                snake2[0].x -= 1;
                isConfused = true
            }
            break;
        case 'left':
            if (!mirrors.some(obstacle => obstacle.x === head.x - 1 && obstacle.y === head.y) && !isCollidingWithBody(head.x - 1, head.y)) {
                cancelEffects()
                direction = 'right';
                snake[0].x += 1
                snake2[0].x += 1
                isConfused = true

            }
            break;
        case 'up':
            if (!mirrors.some(obstacle => obstacle.x === head.x && obstacle.y === head.y - 1) && !isCollidingWithBody(head.x, head.y - 1)) {
                cancelEffects()
                direction = 'down';
                snake[0].y -= 1
                snake2[0].y -= 1
                isConfused = true

            }
            break;
        case 'down':
            if (!mirrors.some(obstacle => obstacle.x === head.x && obstacle.y === head.y + 1) && !isCollidingWithBody(head.x, head.y + 1)) {
                cancelEffects()
                direction = 'up';
                snake[0].y += 1
                snake2[0].y += 1
                isConfused = true
            }
            break;
        default:
            // Handle any other direction cases here
            break;
    }
}

if (!isInvincible && reflector.some(obstacle => obstacle.x === head.x && obstacle.y === head.y)) {
    inverted = !inverted
    return
}
        
projectiles.forEach((projectile, index) => { esnake.forEach((esnake, obstacleIndex) => {
        if (projectile.x >= esnake.x * gridSize && projectile.x <= (esnake.x + 1) * gridSize &&
            projectile.y >= esnake.y * gridSize && projectile.y <= (esnake.y + 1) * gridSize) {
            // Remove the obstacle from the array
            // Create an explosion shockwave
            createExplosion(ctx, projectile.x, projectile.y, projectileColor, obstacles, dynamicObstacles, gridSize, explode);
            
            projectiles.splice(index, 1);
            
            esnake.splice(0, esnake.length);
        }
    });
                                           })
                    
            // Check if Snake eats Food
            if ((head.x === food.x && head.y === food.y) || projectiles.some((projectile, index) => { return projectile.x === food.x && projectile.y === food.y })){
                if (food.type === 'superfood') {
                    cancelEffects()
                    gamefoods.push('superfood')
                    score += 2;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake.unshift({ ...snake[0], color: 'green' });
snake2.unshift({ ...snake2[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });

                    if (esnake.length !== 0) {
                    esnake.unshift({ ...esnake[0], color: timeslow });
                    esnake.unshift({ ...esnake[0], color: timeslow });
                    }

                } else if (food.type === 'poison') {
                    gamefoods.push('poison')
                    cancelEffects()
                    score = Math.max(0, Math.ceil(score / 2)); // Reduce score by 50% rounded up
                    snake.pop()
                    snake.pop()
                    snake.pop()
                    snake2.pop()
                    snake2.pop()
                    snake2.pop()
                } else if (food.type === 'teleport') {
                    gamefoods.push('teleport')
    // Teleport the snake to a random location
    cancelEffects()
        score += 1;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
    const randomX = Math.floor(Math.random() * (canvas.width / gridSize));
    const randomY = Math.floor(Math.random() * (canvas.height / gridSize));
    head.x = randomX;
    head.y = randomY;

    // Randomize the direction
    const directions = ['up', 'down', 'left', 'right']; // Possible directions
    const randomIndex = Math.floor(Math.random() * directions.length);
    direction = directions[randomIndex];
    HaHaNoCollision(10)
                } else if (food.type === 'invincibility') {
                    gamefoods.push('invincibility')
                    cancelEffects()
                    if (gotextralife === false) {
    isFoodOrange = true;
    lives = (lives / 2);
    livecount = livecount + 1;
    gotextralife = true;
}
HaHaNoCollision(100);

                } else if (food.type === 'ice') {
                    cancelEffects()
                    score += 1;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                    gamefoods.push('ice')
                    let pcolor = 'lightblue';
 if (freeze === false){                    
     freeze = true;
     pX = snake[0].x * gridSize + gridSize / 2;
                pY = snake[0].y * gridSize + gridSize / 2;
                    shootWaveOfProjectiles(pX, pY, 30, 360, projectileSpeed, pcolor, obstacles, dynamicObstacles, gridSize, direction, 30, 70, false, 3, false, 20, 1, false,snake)
 } else {
     return;         
 }
                } else if (food.type === 'earth'){
                    cancelEffects()
                    score += 1;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                    gamefoods.push('earth')
                    let x = getSnakeHeadX()
                    let y = getSnakeHeadY()
                    pauseGame()
                    shockwaveAnimation(x, y)
                } else if (food.type === 'fire'){
                    cancelEffects()
                    score += 1;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                    isBurned = true
                    gamefoods.push('fire')
                pX = snake[0].x * gridSize + gridSize / 2;
                pY = snake[0].y * gridSize + gridSize / 2;
                shootWaveOfProjectiles(pX, pY, numberOfProjectiles, 10, projectileSpeed, projectileColor, obstacles, dynamicObstacles, gridSize, direction, 10, 70, true, 3, false, 20, 1, false,snake)
                }else if (food.type === 'ultrafood'){
                    cancelEffects()
                    gamefoods.push('ultrafood')
                    score += 3;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                if (esnake.length !== 0) {
                    esnake.unshift({ ...esnake[0], color: timeslow });
                    esnake.unshift({ ...esnake[0], color: timeslow });
                    esnake.unshift({ ...esnake[0], color: timeslow });
                }
                    
                } else if (food.type === 'air'){
cancelEffects()
    let pcolourr = 'lightgrey'
                    score += 1;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                pX = snake[0].x * gridSize + gridSize / 2;
                pY = snake[0].y * gridSize + gridSize / 2;
                shootWaveOfProjectiles(pX, pY, numberOfProjectiles, waveSpreadAngle, projectileSpeed, pcolourr, obstacles, dynamicObstacles, gridSize, direction, 10, 60, true, 3, false, 20, 1, false,snake)
                }else if (food.type === 'morph'){
                cancelEffects()
                    score += 1;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                pX = snake[0].x * gridSize + gridSize / 2;
                pY = snake[0].y * gridSize + gridSize / 2;
                shootWaveOfProjectiles(pX, pY, 1, 1, 30, neoncolor, obstacles, dynamicObstacles, gridSize, direction, 30, 70, true, 3, true, 100, 2, false,snake)
                }else if (food.type === 'breath'){
                    cancelEffects()
                    score += 1;
                    snake.unshift({ ...snake[0], color: 'green' })
                    snake2.unshift({ ...snake2[0], color: 'green' });
    let repeat = 30; // Initial size
    let timeInteger = 1;
    // Define a function for shooting projectiles with a delay
    function shootWithDelay(number) {
        // Check if size is greater than 0
        repeat = number
        if (repeat > 0) {
            // Calculate position
            const pX = snake[0].x * gridSize + gridSize / 2;
            const pY = snake[0].y * gridSize + gridSize / 2;
            // Shoot projectiles
            shootWaveOfProjectiles(pX, pY, 1, 1, 30, sunset, obstacles, dynamicObstacles, gridSize, direction, 30, 20, true, 3, false, 20, 1, false,snake);
            // Decrease size for the next iteration
            repeat--;
            // Schedule the next execution after a delay

            setTimeout(() => {
            shootWithDelay(repeat);
        }, timeInteger * 100);
                     // Increment timeInteger for the next iteration
            timeInteger++;
        }
    }
    // Start shooting projectiles with a delay
    shootWithDelay(10);

            }else if(food.type === 'slow') {
                    cancelEffects()
                    isSlow = true
                    score += 1;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                      changeInterval(150)
                    
// Set timeout to reset the interval back to 100ms after 6000 milliseconds
setTimeout(() => {
  changeInterval(100);
  isSlow = false;
}, 6000); 
                }else if(food.type === 'fast'){
                    cancelEffects()
                    isFast = true
                        score += 1;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
                    changeInterval(50)   
                setTimeout(function() {
    changeInterval(100);
    isFast = false
}, 3000);           
                }else{
                    cancelEffects()
                    gamefoods.push('normal')
                    score += 1;
                    snake.unshift({ ...snake[0], color: 'green' });
                    snake2.unshift({ ...snake2[0], color: 'green' });
if (esnake.length !== 0) {
                    esnake.unshift({ ...esnake[0], color: timeslow });
}
                  }
                isEating = true;
                eatingAnimationFrames = 8; // Set the number of frames for the eating animation
                spawnFood();

if (Math.random() < itemSpawn()) {
                    spawnItem();
}
                // More frequent black blocks as score increases
                if (Math.random() < calculateObstacleSpawnProbability()) {
                    spawnObstacle();
                }
            }
            // Assuming symbiote is an array of objects with x, y, and type properties
            if (symbiote.length !== 0){
symbiote.forEach((symbiote, index) => {
    if (symbiote.x === snake[1].x && symbiote.y === snake[1].y) {
        if (symbiote.type === 'magnet') {
   if (isPaused === false){
            let startNode = { x: food.x, y: food.y };
    // End node is the head of the player snake (snake[0])
    let endNode = { x: (track[0].x), y: (track[0].y) };

    // Implement A* algorithm to find the shortest path from startNode to endNode
    let path = aStarPathfinding(startNode, endNode, canvas, gridSize);

    // Move the enemy snake towards the next node in the path
    if (path.length > 1) {
        // Next node in the path
        let nextNode = path[1];
        // Move towards the next node
        if (nextNode.x < food.x) {
            // Move left
            food.x = (food.x - enemymovementspeed + canvas.width / gridSize) % (canvas.width / gridSize);
        } else if (nextNode.x > food.x) {
            // Move right
            food.x = (food.x + enemymovementspeed) % (canvas.width / gridSize);
        } else if (nextNode.y < food.y) {
            // Move up
            food.y = (food.y - enemymovementspeed + canvas.height / gridSize) % (canvas.height / gridSize);
        } else if (nextNode.y > food.y) {
            // Move down
            food.y = (food.y + enemymovementspeed) % (canvas.height / gridSize);
        }
    }
   }
}else if (symbiote.type === 'wave'){
            pX = snake[0].x * gridSize + gridSize / 2;
                pY = snake[0].y * gridSize + gridSize / 2;
                shootWaveOfProjectiles(pX, pY, numberOfProjectiles, 10, projectileSpeed, projectileColor, obstacles, dynamicObstacles, gridSize, direction, 10, 70, true, 3, false, 20, 1, false)
            }
    }
    });
            }
if (!isInvincible && timezone.some(obstacle => obstacle.x === head.x && obstacle.y === head.y)) {
    pickrandomeffect()
 if (timezone.type === 'teleport') {
                    gamefoods.push('teleport')
    // Teleport the snake to a random location
    const randomX = Math.floor(Math.random() * (canvas.width / gridSize));
    const randomY = Math.floor(Math.random() * (canvas.height / gridSize));
    head.x = randomX;
    head.y = randomY;

    // Randomize the direction
    const directions = ['up', 'down', 'left', 'right']; // Possible directions
    const randomIndex = Math.floor(Math.random() * directions.length);
    direction = directions[randomIndex];
}        
}
// Check if there are items in the list
if (item.length !== 0) {
    // Check if the head is at the same position as the first item
    if (head.x === item[0].x && head.y === item[0].y) {
        // Check if the item is of type 'taxform'
        if (item[0].type === 'taxform') {
            // Set TaxFormGot to true
            TaxFormGot = true;
        } else if (item[0].type === 'antidote'){
            cancelEffects()
        }else if (item[0].type === 'welldelete'){
         wells = []   
        }else if (item[0].type === 'coin'){
taxrate += 0.01
        }
        // Clear the item list
        item = [];
        pickUpItem(item)
    }
}

// Check if there are any enemies matching the criteria and if TaxFormGot is true
if (esnake.some(esnake => esnake.type === 'IRS') && TaxFormGot === true) {
    // Clear the enemy list
    esnake = [];
    TaxFormGot = false
}

            if (taxrate >= 1.00){
                taxrate = 0.20
            }

checkForEffects()
    if (!isPaused) { // Check if the game is not paused
        // Move Snake
        if (!isParalyzed){
        snake.pop();
        snake.unshift(head);
        snake2.pop()
        snake2.unshift(head2)
        }
if (!freeze) {
        // Move Dynamic Obstacles
        dynamicObstacles.forEach(obstacle => {
            if (obstacle.id === 1) {
                // Left to right movement
                obstacle.x += 0.25;
                if (obstacle.x + 1 > canvas.width / gridSize) {
                    obstacle.x = 0; // Reset to the left side if it goes beyond the canvas boundary
                }
            } else if (obstacle.id === 2) {
                // Up and down movement
                obstacle.y += 0.25;
                if (obstacle.y + 1 > canvas.height / gridSize) {
                    obstacle.y = 0; // Reset to the top if it goes beyond the canvas boundary
                }
            }
        });

goombas.forEach(obstacle => {
    if (obstacle.direction === undefined){
     obstacle.direction = 'left'   
    }
})
goombas.forEach(obstacle => {
  // Simplify the condition for moving up and down
  if (obstacle.y + 3 + 0.60 <= canvas.height / gridSize) {
    obstacle.y += 1;
  }

  // Ensure we're close enough to the target to account for floating-point precision
  const epsilon = 0.01; // Small tolerance value
  if (Math.abs(obstacle.y + 3 + 1.00) >= (canvas.height / gridSize)-epsilon) {
    if (obstacle.direction === 'left'){
     obstacle.x += 0.5
     if (obstacle.x + 2 >= canvas.width/gridSize){
    obstacle.direction = 'right'
     }
    }
    if (obstacle.direction === 'right') {
    obstacle.x -= 0.5;  // Moves the obstacle to the right
    if (obstacle.x - 2 <= 0) {  // Assuming 20 is the right boundary
      obstacle.direction = 'left';
    }
  }   
  }
});

// Check for collisions with the player's head and remove the Goomba
goombas.forEach((obstacle, index) => {
  if (obstacle.y === head.y && Math.abs(obstacle.x - head.x) <= 0.5 && direction === 'down') {
    goombas.splice(index, 1);
    score += 1;
  }
});

        thwomps.forEach(obstacle => {
            if (obstacle.state === 2) {
                // Left to right movement
                obstacle.y -= 0.25;
                if (obstacle.y + 1 === 0) {
                    obstacle.state = 1; // Reset to the top if it goes beyond the canvas boundary
                }
                }else if (obstacle.state === 1) {
                // Up and down movement
                obstacle.y += 1;
                if (obstacle.y + 1 > canvas.height / gridSize) {
                    obstacle.state = 2; // Reset to the top if it goes beyond the canvas boundary
                }
            }           
                   
            }
        );
}}

    // Randomize the direction
    const types = ['magnet']; // Possible directions
    const randomIndex = Math.floor(Math.random() * types.length);
    type = types[randomIndex];


            // Check for victory
if (score >= maxscore || chaosdefeated === true) {
    declareVictory();
}
if (score >= maxscore / 2) {
    if (symbiote.length === 0) {
                symbiote = Array.from({ length: snake.length }, (_, index) => ({ x: 10, y: 10 - index, type: type }));
            }
    }

if (reflector.length === 12 && kamek.length === 0 && kamekappears === false && firelord.length ===0) {
    let kamekX2 = Math.floor(Math.random() * (canvas.width / gridSize));
    let kamekY2 = Math.floor(Math.random() * (canvas.height / gridSize));
    isPaused = true
    reflector = []
    kamekappears = true
    let gridOffset = ((2*gridSize) + (gridSize / 2))/2
            // Call the function with desired parameters
        createPortalAnimation(kamekX2* gridSize, (kamekY2 * gridSize) + gridOffset, 120, 5000);
    setTimeout(() => {
kamek.push({ x: kamekX2, y: kamekY2 });
    }, 2500);
    setTimeout(() => {
        isPaused = false
    }, 5000);
}

            
            if (laser.isShooting) {
        obstacles.forEach((obstacle, index) => {
            // Check if the laser intersects with the obstacle
            if (checkCollision(laser.x1, laser.y1, laser.x2, laser.y2, obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize)) {
                // If there's a collision, remove the obstacle from the array
                obstacles.splice(index, 1);
            }
        });
    }
        }
        function calculateObstacleSpawnProbability() {
            // Obstacle spawn probability increases with score
            return Math.min(0.1 + score / 100, 1); // Adjust the maximum spawn probability as needed
        }

function itemSpawn() {
            // Obstacle spawn probability increases with score
            return Math.min(0.1 + score / 99, 1); // Adjust the maximum spawn probability as needed
        }

function spawnItem() {
            let newItem;
            do {
                newItem = {
                    x: Math.floor(Math.random() * (canvas.height / gridSize)),
                    y: Math.floor(Math.random() * (canvas.height / gridSize)),
                    type: generateItem()
                };
            } while (snake.some(segment => segment.x === newItem.x && segment.y === newItem.y) ||
                obstacles.some(obstacle => obstacle.x === newItem.x && obstacle.y === newItem.y) ||
                dynamicObstacles.some(obstacle => (newItem.x >= obstacle.x && newItem.x < obstacle.x + 1) &&
                    (newItem.y >= obstacle.y && newItem.y < obstacle.y + 1)));

    item = []
            item.push(newItem);
        }

function generateItem() {
            // Adjust the probability for different types of food as needed
            const random = Math.random();
            if (random <= 0.1) {
const rare = ['antidote']; // Possible directions
                foodCounts.rare = rare.length
    const randomIndex2 = Math.floor(Math.random() * rare.length);
    return rare[randomIndex2];
            } else if (random <= 0.4) {
    const Special = ['welldelete', 'coin']; // Possible directions
                foodCounts.special = Special.length
    const randomIndex2 = Math.floor(Math.random() * Special.length);
    return Special[randomIndex2];
            } else{
                const common = ['taxform']; // Possible directions
                foodCounts.common = common.length
    const randomIndex2 = Math.floor(Math.random() * common.length);
    return common[randomIndex2];
            }
        }
        
        function spawnFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * (canvas.height / gridSize)),
                    y: Math.floor(Math.random() * (canvas.height / gridSize)),
                    type: generateFoodType()
                };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
                obstacles.some(obstacle => obstacle.x === newFood.x && obstacle.y === newFood.y) ||
                dynamicObstacles.some(obstacle => (newFood.x >= obstacle.x && newFood.x < obstacle.x + 1) &&
                    (newFood.y >= obstacle.y && newFood.y < obstacle.y + 1)));

            food = newFood;
        }


        function generateFoodType() {
            // Adjust the probability for different types of food as needed
            const random = Math.random();
            if (random <= 0.01) {
const rare = ['invincibility']; // Possible directions
                foodCounts.rare = rare.length
    const randomIndex2 = Math.floor(Math.random() * rare.length);
    return rare[randomIndex2];
            } else if (random <= 0.4) {
    const Special = ['teleport', 'earth', 'ice', 'fire', 'air', 'poison', 'morph', 'slow', 'breath', 'fast']; // Possible directions
                foodCounts.special = Special.length
    const randomIndex2 = Math.floor(Math.random() * Special.length);
    return Special[randomIndex2];
            } else{
                const common = ['normal', 'superfood', 'ultrafood']; // Possible directions
                foodCounts.common = common.length
    const randomIndex2 = Math.floor(Math.random() * common.length);
    return common[randomIndex2];
            }
        }

function spawnObstacle() {
    const x = Math.floor(Math.random() * (canvas.width / gridSize));
    const y = Math.floor(Math.random() * (canvas.height / gridSize));

    // Check if the coordinates are already occupied by something else
    const occupied = obstacles.some(obstacle => obstacle.x === x && obstacle.y === y) ||
                     mirrors.some(mirror => mirror.x === x && mirror.y === y) ||
                     dynamicObstacles.some(dynamic => dynamic.x === x && dynamic.y === y) ||
                     (food.x === x && food.y === y);

    if (occupied) {
        return; // Exit the function if the position is already occupied
    }
const randomValue = Math.random()
    const specialTypes = ['snake', 'polygon', 'dynamic', 'square', 'square','thwomp'];
    const randomIndex2 = Math.floor(Math.random() * specialTypes.length);
    const special2 = specialTypes[randomIndex2];

    if (special2 === 'snake' && esnake.length === 0 && randomValue <= 0.2) {
        const etypes = ['base', 'IRS']; // Possible types
        const randomIndex = Math.floor(Math.random() * etypes.length);
        const etype = etypes[randomIndex];
        esnake = Array.from({ length: startingLength }, (_, index) => ({
            x: 1,
            y: 10 - index,
            color: timespeed,
            damage: false,
            type: etype
        }));
        
    } 
    if (special2 === 'polygon') {
        formrandomshape(2);
    } 
    if (special2 === 'thwomp') {
        thwomps.push({ x: x, y: 0, state: 1 });
    } 
    if (special2 === 'dynamic') {
        const id = Math.random() < 0.5 ? 1 : 2;
        dynamicObstacles.push({ x: x, y: y, id: id });
    } 
    if (special2 === 'square') {
        let otype = 0;
        if (controltype === 'arrow') {
            const rare = [obstacles, mirrors, wells, reflector, reflector];
            const randomIndex2 = Math.floor(Math.random() * rare.length);
            otype = rare[randomIndex2];
        } 
        if (controltype === 'mobile' || controltype === 'set') {
            const rare = [obstacles, mirrors, reflector, reflector];
            const randomIndex2 = Math.floor(Math.random() * rare.length);
            otype = rare[randomIndex2];
        }
        otype.push({ x: x, y: y });
    }
}

        function restartGame() {
            cancelEffects()
            pauseGame();
            shield = false
            GravityApplied = false
            const numSegmentsToRemove2 = Math.ceil(reflector.length * 0.01);
            if (reflector.length !== 0){
        if (reflector.length > numSegmentsToRemove2) {
            reflector.splice(0, numSegmentsToRemove2);
        }
            }
            
            const numSegmentsToRemovefrommirrorarray = Math.ceil(mirrors.length * 0.01);
            if (mirrors.length !== 0){
            if (mirrors.length > numSegmentsToRemovefrommirrorarray) {
            mirrors.splice(0, numSegmentsToRemovefrommirrorarray);
        }
            }
            inverted = false
            turrets = []
            lords = [firelord, lightninglord, icelord, earthlord]
            goombas = []
            TaxFormGot = false
            createParticles('red');
            animateExplosion();
            pauseGame();
            gotextralife = false;
            taxrate = 0.20
            symbiotes = []
            thwomps = []
            snake = Array.from({ length: startingLength }, (_, index) => ({ x: 10, y: 10 - index, color: 'green' }));
            snake2 = Array.from({ length: startingLength }, (_, index) => ({ x: 10, y: 10 - index, color: 'green' }));
            obstacles = [];
            gamefoods = [];
            dynamicObstacles = [];
            score = 0;
            esnake = []        
            timezone = []
            isEating = false;
            projectiles = []
            lava = []
            lavacoords = []
            firelord = []
            ice = []
            electric = []
            earth = []
            ghostLord = []
            chaosdefeated = false
            ectoplasm = []
            chaosLord = []
            isghostdead = false
            lightninglord = []
            icelord = []
            earthlord = []
            isInvincible = false;
            eatingAnimationFrames = 0;
            lives = 0.5;
            livecount = 2;
            kamek = []
            kamekappears = false
            firstControlSchemeSet = false;
            cangetvenom = true
            wells = []
            checkAndSplice(polygons, mirrors)
            polygons = []
            venomreset()
            spawnFood();
            changeInterval(100)
        }

 

        function declareVictory() {
            pauseGame()
            reflector = []
            mirrors = []
            createParticles('gold');
            animateExplosion();
            pauseGame()
            restartGame();
        }
        
// Set up explosion animation properties
let particles = [];
const numParticles = 200;
const explosionForce = 50;
const holeSize = 20 * antiZoomFactor;

// Function to create a particle
// Function to calculate the X position of the snake's head
function getSnakeHeadX() {
    return snake[0].x * gridSize + gridSize / 2;
}

// Function to calculate the Y position of the snake's head
function getSnakeHeadY() {
    return snake[0].y * gridSize + gridSize / 2;
}

// Modify the Particle constructor to accept head position parameters
function Particle(x, y, radius, color, headX, headY) {
    this.x = x + headX; // Calculate the particle's position relative to the snake's head
    this.y = y + headY;
    this.radius = radius;
    this.color = color;
    this.velocity = {
        x: (Math.random() - 0.5) * explosionForce * (Math.random() * 2),
        y: (Math.random() - 0.5) * explosionForce * (Math.random() * 2)
    };
    this.alpha = 1;
    this.update = function() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.alpha -= 0.01;
        this.draw();
    };
    this.draw = function() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
        ctx.fillStyle = 'gold';
        ctx.fill();
        ctx.restore();
    };
}

// Modify the createParticles function to pass head position parameters
        function createParticles(colorName) {
            const color = tinycolor(colorName).toHexString(); // Convert color name to hexadecimal color code
            const headX = getSnakeHeadX();
            const headY = getSnakeHeadY();
            for (let i = 0; i < numParticles; i++) {
                const particle = new Particle(0, 0, 5, color, headX, headY);
                particles.push(particle);
            }
        }


function simulateHoles(color) {
    ctx.fillStyle = color; // Use the color passed as a parameter
    particles.forEach(particle => {
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, holeSize, 0, Math.PI * 2);
        ctx.fill();
    });
}

function animateExplosion() {
    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update and draw particles
    particles.forEach((particle, index) => {
        particle.update();
        if (particle.alpha <= 0) {
            particles.splice(index, 1);
        }
    });

    // Simulate holes with the color of the particles
    simulateHoles(particles[0].color); // Pass the color of the first particle

    // Request animation frame
    if (particles.length > 0) {
        requestAnimationFrame(animateExplosion);
    }
}


                function gameLoop() {
            resizeCanvas(); // Resize the canvas on every game loop iteration
            resizeCanvasHeight();
            update();
            draw()
            physicsActive = false;
                        if (kamek.length === 0 && firelord.length === 0 && icelord.length === 0 && lightninglord.length === 0 && earthlord.length === 0) {
    applyStatus(5000, 'gravity');
} else {
    GravityApplied = false;
}
if (firelord.length !== 0 || icelord.length !== 0 || lightninglord.length !== 0 || earthlord.length !== 0 || kamek.length !== 0 || ghostLord.length !== 0 || chaosLord.length !== 0){
GravityApplied = false;
}
            applyGravity()
                    physicsActive = false;
                    if (DoDisplayCheck){
            displaycheck()
            manageWellsWarningZone()
                    }
            if (isGravityWellActive === true && wells.length !== 0){
            checkDistance(snake)
            }
if (snake.length <= 1){
    restartGame()
}
if (esnake.length !== 0) {
if (isPaused === false){
            enemyAI(esnake, canvas, gridSize) 
}}
            if (symbiote.length !== 0){
            if (isPaused === false){
symbioteAi(symbiote, canvas, gridSize)
            }}
            if (isBurned === true || isIced === true){
                    changeInterval(50)
} else if (isBurned === false && currentInterval === 0.5 && isFast === false){
    changeInterval(100)
            }
if (isSlow === true || isEarthed === true){
changeInterval(150)
}else if (currentInterval === 1.5 && isSlow === false && isEarthed === false){
changeInterval(100)
}
if (lords.length === 2 && firelord.length ===0&& icelord.length ===0 && lightninglord.length === 0 && earthlord.length === 0){
const randomIndex = Math.floor(Math.random() * lords.length);
    let selectedLord = lords[randomIndex];
        selectedLord.push({ x: startX/gridSize, y: startY/gridSize });
        
    lords.splice(randomIndex, 1);
}
if (lords.length === 1 && firelord.length ===0&& icelord.length ===0 && lightninglord.length === 0 && earthlord.length === 0){
const randomIndex = Math.floor(Math.random() * lords.length);
    let selectedLord2 = lords[randomIndex];
        selectedLord2.push({ x: startX/gridSize, y: startY/gridSize });
        
    lords.splice(randomIndex, 1);
}
if (lords.length === 3 && firelord.length ===0&& icelord.length ===0 && lightninglord.length === 0 && earthlord.length === 0){
    lords = [firelord, lightninglord, icelord, earthlord]
const randomIndex = Math.floor(Math.random() * lords.length);
    let selectedLord3 = lords[randomIndex];
        selectedLord3.push({ x: startX/gridSize, y: startY/gridSize });
        
    lords.splice(randomIndex, 1);
}   
            if (iskamekdead === true && firelord.length ===0&& icelord.length ===0 && lightninglord.length === 0 && earthlord.length === 0){
const randomIndex = Math.floor(Math.random() * lords.length);
    let selectedLord = lords[randomIndex];
        selectedLord.push({ x: startX/gridSize, y: startY/gridSize });
        
    lords.splice(randomIndex, 1);
}
if (lords.length === 0 && firelord.length ===0&& icelord.length ===0 && lightninglord.length === 0 && earthlord.length === 0){
        ghostLord.push({ x: startX/gridSize, y: startY/gridSize });
}
                    if (isghostdead === true && ghostLord.length === 0){
chaosLord.push({ x: startX/gridSize, y: startY/gridSize });
                    }
// Handle eating animation
            if (isEating) {
                eatingAnimationFrames--;

                // Apply the wavelike animation
                for (let i = 1; i < snake.length; i++) {
                    if (i <= eatingAnimationFrames) {
                        snake[i].color = 'green';
                    }
                }

                if (eatingAnimationFrames === 0) {
                    isEating = false;
                }
            }
        }

function closestNumber(n, m) {
    // Find the quotient
    let q = Math.floor(n / m);

    // 1st possible closest number
    let n1 = m * q;

    // 2nd possible closest number
    let n2 = m * (q + 1);

    // Ensure that n1 does not exceed n
    if (n1 > n) {
        return n;
    }

    // Ensure that n2 does not exceed n
    if (n2 > n) {
        return n1;
    }

    // Return the closest multiple of m to n
    return Math.abs(n - n1) < Math.abs(n - n2) ? n1 : n2;
}

function resizeCanvas() {
    const canvasWidth = closestNumber(window.innerWidth, gridSize);
    const canvasHeight = closestNumber(window.innerHeight, gridSize);

    // Set canvas width and height
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // Adjust food position if it's out of bounds
    if (food.x >= canvasWidth / gridSize) {
        food.x = canvasWidth / gridSize - 1;
    }
    if (food.y >= canvasHeight / gridSize) {
        food.y = canvasHeight / gridSize - 1;
    }
    if (
    obstacles.some(obstacle => obstacle.x === food.x && obstacle.y === food.y) ||
    dynamicObstacles.some(obstacle => 
        (food.x >= obstacle.x && food.x < obstacle.x + 2) &&
        (food.y >= obstacle.y && food.y < obstacle.y + 2)
    ) ||
    mirrors.some(obstacle => obstacle.x === food.x && obstacle.y === food.y)
|| timezone.some(obstacle => obstacle.x === food.x && obstacle.y === food.y)
||reflector.some(obstacle => obstacle.x === food.x && obstacle.y === food.y)
||thwomps.some(obstacle => 
        (food.x >= obstacle.x && food.x < obstacle.x + 2) &&
        (food.y >= obstacle.y && food.y < obstacle.y + 2)
    )) {
    food.x += 1;
    food.y += 1;
}
obstacles.forEach((obstacle, obstacleIndex) => {
  mirrors.forEach((mirror, mirrorIndex) => {
    if (mirror.x === obstacle.x && mirror.y === obstacle.y) {
      obstacle.x += 1;
      obstacle.y += 1;
    }
  });
});
}


if ((controltype === 'set' || controltype === 'arrow') && controltype !== 'mobile') {
    // Handle arrow key presses
    document.addEventListener('keydown', event => {
        // If a control scheme is already set, return early
        if (firstControlSchemeSet && controltype !== 'arrow') return;

        // Prevent default arrow key behavior (scrolling)
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
            event.preventDefault();
        }

        if (!isPaused) {
            switch (event.key) {
                case 'ArrowUp':
                    direction = 'up';
                    controltype = 'arrow';
                    isGravityWellActive = true;
                    break;
                case 'ArrowDown':
                    direction = 'down';
                    controltype = 'arrow';
                    isGravityWellActive = true;
                    break;
                case 'ArrowLeft':
                    direction = 'left';
                    controltype = 'arrow';
                    isGravityWellActive = true;
                    break;
                case 'ArrowRight':
                    direction = 'right';
                    controltype = 'arrow';
                    isGravityWellActive = true;
                    break;
            }
            // Set the flag once a control type is chosen
            if (!firstControlSchemeSet) {
                firstControlSchemeSet = true;
            }
        }
    });
}

if ((controltype === 'set' || controltype === 'mobile') && controltype !== 'arrow') {
    if (!isPaused) {
        // Handle touch events for mobile controls
        let touchStartX = 0;
        let touchStartY = 0;

        function handleTouchStart(event) {
            // If a control scheme is already set, return early
            if (firstControlSchemeSet && controltype !== 'mobile') return;

            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }

        function handleTouchEnd(event) {
            // If a control scheme is already set, return early
            if (firstControlSchemeSet && controltype !== 'mobile') return;

            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                direction = deltaX > 0 ? 'right' : 'left';
                controltype = 'mobile';
            } else {
                // Vertical swipe
                if (Math.abs(deltaY) > 10) {
                    direction = deltaY > 0 ? 'down' : 'up';
                    controltype = 'mobile';
                }
            }

            // Perform actions based on direction if needed
            if (!firstControlSchemeSet) {
                firstControlSchemeSet = true;
            }
        }

        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchend', handleTouchEnd);
    }
}

        // Start the game loop
        let gameInterval = setInterval(gameLoop, 100); // Adjust the interval as needed

function changeInterval(interval) {
    clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, interval);
    currentInterval = interval/100
}

        function getZoomFactor() {
            var deviceWidth, landscape = Math.abs(window.orientation) == 90
            // workaround for strange screen.height on the iPhone (v3.1.3)
            if (window.screen.width == 320) deviceWidth = landscape ? 480 : 320
            else deviceWidth = window.screen[landscape ? "height" : "width"]
            var zoomFactor = deviceWidth / window.innerWidth;
            var antiZoomFactor = 1 / zoomFactor;
          
            // Apply zoom and anti-zoom factors to grid size
            gridSize = Math.max(0, Math.ceil(startingGridSize * antiZoomFactor));
            document.getElementById('scoreDisplay').style.top = (20 * antiZoomFactor) + 'px';
            document.documentElement.style.setProperty('--grid-size', (20 * antiZoomFactor) + 'px');
            psize = gridSize;
        }

        setInterval(getZoomFactor, 1); // Adjust the interval as needed

        // Clean up the interval when the window is closed
        window.addEventListener('beforeunload', () => {
            clearInterval(gameInterval);
        });
// Function to resize the canvas height based on viewport height
function resizeCanvasHeight() {
    const windowHeight = window.innerHeight; // Get the viewport height
    const canvasHeight = closestNumber(window.innerHeight, gridSize);; // Adjust the canvas height to be a multiple of gridSize
    canvas.height = canvasHeight; // Set the canvas height
}

// Call the resizeCanvasHeight function initially to set the canvas height
resizeCanvasHeight();

// Call the resizeCanvasHeight function whenever the window is resized
window.addEventListener('resize', resizeCanvasHeight);

                function adjustForZoom() {
            // Calculate the zoom factor
            const zoomFactor = window.innerWidth / window.screen.availWidth;
            // Adjust the grid size based on the zoom factor
            document.documentElement.style.setProperty('--grid-size', (20 * antiZoomFactor) + 'px');
            // Adjust the position of the score display
            const scoreDisplay = document.getElementById('scoreDisplay');
            scoreDisplay.style.marginTop = `calc(var(--grid-size) * antiZoomFactor)`;
            scoreDisplay.style.fontSize = `var(--grid-size)`;
        }
window.addEventListener('resize', getZoomFactor);
        // Call the adjustForZoom function initially and on window resize
        window.addEventListener('resize', adjustForZoom);
        adjustForZoom();

    canvas.addEventListener('touchstart', PauseHoldStart) 
let touchStartTime; // Variable to store the time when touch starts
canvas.addEventListener('touchstart', PauseHoldStart); // Listen for touchstart event

// Function to handle touchstart event
function PauseHoldStart(event) {
    touchStartTime = new Date().getTime(); // Record the time when touch starts
    setTimeout(checkHold, pausetimer); // Check after 1.5 seconds if the touch is still held
}

// Function to check if touch is still held after 1.5 seconds
function checkHold() {
    // Check if touch is still active and hasn't moved for 1.5 seconds
    if (touchStartTime && (new Date().getTime() - touchStartTime >= pausetimer)) {
        pauseGame(); // Trigger the action if touch is held for 1.5 seconds
    }
}


// Listen for touchend event to reset the timer if touch is released before 1.5 seconds
canvas.addEventListener('touchend', PauseHoldEnd);

// Function to handle touchend event
function PauseHoldEnd() {
    touchStartTime = null; // Reset the touch start time
}
    </script>
</body>
</html>
