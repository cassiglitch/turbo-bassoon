<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lost in Time Snake</title>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            border: 1px solid black;
            display: block;
            margin: auto;
            touch-action: none; /* Disable default touch actions */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const gridSize = 20;
        const canvasSize = 400;
        const snake = [{ x: 10, y: 10 }];
        const directions = { left: { x: -1, y: 0 }, right: { x: 1, y: 0 }, up: { x: 0, y: -1 }, down: { x: 0, y: 1 } };
        let currentDirection = directions.right;
        let food = getRandomFoodPosition();
        let gravityDirection = { x: 0, y: 1 }; // Downward gravity
        let gravityStrength = 0.05; // Adjust gravity strength as needed

        // Initialize Hammer.js for swipe detection
        const hammertime = new Hammer(canvas);
        hammertime.get('swipe').set({ direction: Hammer.DIRECTION_ALL });

        hammertime.on('swipeleft', () => changeDirection('left'));
        hammertime.on('swiperight', () => changeDirection('right'));
        hammertime.on('swipeup', () => changeDirection('up'));
        hammertime.on('swipedown', () => changeDirection('down'));

        function getRandomFoodPosition() {
            return {
                x: Math.floor(Math.random() * (canvasSize / gridSize)),
                y: Math.floor(Math.random() * (canvasSize / gridSize))
            };
        }

        function changeDirection(newDirection) {
            const oppositeDirections = { up: 'down', down: 'up', left: 'right', right: 'left' };
            if (newDirection !== oppositeDirections[currentDirection]) {
                currentDirection = directions[newDirection];
            }
        }

        function applyGravity() {
            // Gradually align with gravity direction
            currentDirection.x += (gravityDirection.x - currentDirection.x) * gravityStrength;
            currentDirection.y += (gravityDirection.y - currentDirection.y) * gravityStrength;
        }

        function draw() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvasSize, canvasSize);

            // Draw the snake
            ctx.fillStyle = 'green';
            snake.forEach(segment => {
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
            });

            // Draw the food
            ctx.fillStyle = 'red';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);
        }

        function update() {
            // Apply gravity
            applyGravity();

            const head = {
                x: (snake[0].x + currentDirection.x + canvasSize / gridSize) % (canvasSize / gridSize),
                y: (snake[0].y + currentDirection.y + canvasSize / gridSize) % (canvasSize / gridSize)
            };

            // Move the snake
            snake.unshift(head);

            // Check if snake eats food
            if (head.x === food.x && head.y === food.y) {
                food = getRandomFoodPosition();
            } else {
                snake.pop();
            }
        }

        function loop() {
            update();
            draw();
            setTimeout(loop, 100);
        }

        loop();
    </script>
</body>
</html>
